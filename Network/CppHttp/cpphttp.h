#ifndef CPPHTTP_H
#define CPPHTTP_H

//
// Original Code Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
// Modified Code Copyright (c) 2016 Oliver W. Adams (owacoder at gmail dot com)
//
// Distributed under the following license:
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

// This file implements an HTTP interface that should conform to the RFC 7230
// standard found at https://tools.ietf.org/html/rfc7230

/*
 * TODO:
 *
 *     upload_progress_callback is not yet supported
 *     reconnect_if_aborted should be implemented in more than write_request(), read_status_line(),
 *         and read_headers()?
 *
 */

#include <stdint.h>
#include <string>
#include <boost/algorithm/string.hpp> /* to_upper_copy, trim */
#include <boost/lexical_cast.hpp> /* cast string to size_t */
#include <boost/asio.hpp>
#ifdef ENABLE_SSL
#include <boost/asio/ssl.hpp> /* HTTPS communication */
#endif
#include <boost/bind.hpp> /* Asynchronous callbacks */

#include <vector>
#include <string>

#ifdef BOOST_WINDOWS
# include <windows.h>
# include <Wincrypt.h>
# include <boost/asio/ssl.hpp>

    namespace CppHttp
    {
        inline std::vector<std::string> system_certificates(const char *section)
        {
            std::vector<std::string> certs;

            HCERTSTORE hStore;
            PCCERT_CONTEXT pCertContext = NULL;

            if (!(hStore = ::CertOpenStore(
                      CERT_STORE_PROV_SYSTEM_A,
                      0,
                      (HCRYPTPROV_LEGACY) NULL,
                      CERT_SYSTEM_STORE_CURRENT_USER,
                      section)))
                return certs;

            do
            {
                if ((pCertContext = ::CertFindCertificateInStore(
                          hStore,
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                          0,
                          CERT_FIND_ANY,
                          NULL,
                          pCertContext)))
                {
                    SYSTEMTIME systemNow;
                    FILETIME fileNow;
                    ULARGE_INTEGER diff1, diff2;
                    const DWORD flags = CRYPT_STRING_BASE64HEADER;
                    DWORD len;
                    PCHAR str;

                    // Only accept currently valid certificates
                    ::GetSystemTime(&systemNow);

                    if (!::SystemTimeToFileTime(
                              &systemNow,
                              &fileNow))
                        break;

                    diff1.LowPart = fileNow.dwLowDateTime;
                    diff1.HighPart = fileNow.dwHighDateTime;

                    diff2.LowPart = pCertContext->pCertInfo->NotBefore.dwLowDateTime;
                    diff2.HighPart = pCertContext->pCertInfo->NotBefore.dwHighDateTime;

                    if (std::min(diff1.QuadPart, diff2.QuadPart) < diff2.QuadPart)
                        continue;

                    diff2.LowPart = pCertContext->pCertInfo->NotAfter.dwLowDateTime;
                    diff2.HighPart = pCertContext->pCertInfo->NotAfter.dwHighDateTime;

                    if (std::max(diff1.QuadPart, diff2.QuadPart) > diff2.QuadPart)
                        continue;

                    // Get Base64 string length
                    if (!::CryptBinaryToStringA(
                              pCertContext->pbCertEncoded,
                              pCertContext->cbCertEncoded,
                              flags,
                              NULL,
                              &len))
                        break;

                    if (len)
                    {
                        str = new char[len];

                        if (!::CryptBinaryToStringA(
                                  pCertContext->pbCertEncoded,
                                  pCertContext->cbCertEncoded,
                                  flags,
                                  str,
                                  &len))
                        {
                            delete[] str;
                            break;
                        }

                        certs.push_back(std::string(str, (size_t) len));

                        delete[] str;
                    }
                }
            } while (pCertContext);

            if (pCertContext)
                ::CertFreeCertificateContext(pCertContext);

            ::CertCloseStore(
                      hStore,
                      CERT_CLOSE_STORE_FORCE_FLAG);

            return certs;
        }

        inline std::vector<std::string> system_root_certificates()
        {
            return system_certificates("Root");
        }

        inline std::vector<std::string> system_my_certificates()
        {
            return system_certificates("MY");
        }

        inline std::vector<std::string> system_trust_certificates()
        {
            return system_certificates("Trust");
        }

        inline std::vector<std::string> system_ca_certificates()
        {
            return system_certificates("CA");
        }

        inline std::vector<std::string> system_userds_certificates()
        {
            return system_certificates("UserDS");
        }
    }
#else
# include <fstream>
# include <iostream>
# include <boost/algorithm/string.hpp>

    // TODO: certificates may be found in different files on different distributions

    namespace CppHttp
    {
        inline std::vector<std::string> system_certificates(const char *filename)
        {
            std::ifstream file;
            std::vector<std::string> certs;
            std::string cert, line;

            try
            {
                file.open(filename);

                while (std::getline(file, line))
                {
                    cert.append(line + "\n");
                    if (boost::to_lower_copy(line) == "-----end certificate-----")
                    {
                        certs.push_back(cert);
                        cert.clear();
                    }
                }

                file.close();
            } catch (std::ios_base::failure &) {}

            return certs;
        }

        inline std::vector<std::string> system_certificates(const char **files)
        {
            std::vector<std::string> certs;

            while (*files)
            {
                certs = system_certificates(*files);
                if (!certs.empty())
                    return certs;
                ++files;
            }

            return certs;
        }

        inline std::vector<std::string> system_certificates()
        {
            static const char *locations[] =
            {
                "/etc/ssl/certs/ca-certificates.crt",   // Debian-based distributions
                "/etc/pki/tls/certs/ca-bundle.crt",     // Fedora
                NULL
            };

            return system_certificates(locations);
        }

        inline std::vector<std::string> system_root_certificates()
        {
            return system_certificates();
        }

        inline std::vector<std::string> system_my_certificates()
        {
            return system_certificates();
        }

        inline std::vector<std::string> system_trust_certificates()
        {
            return system_certificates();
        }

        inline std::vector<std::string> system_ca_certificates()
        {
            return system_certificates();
        }

        inline std::vector<std::string> system_userds_certificates()
        {
            return system_certificates();
        }
    }
#endif // BOOST_WINDOWS

namespace CppHttp
{
    using namespace boost::asio::ip;

    class Uri
    {
        int decOctet(const char *str, int &len) const
        {
            int octet = 0;
            if (!isdigit(str[0]))
            {
                len = 0;
                return -1;
            }
            octet = str[0] - '0';
            if (!isdigit(str[1]))
            {
                len = 1;
                return octet;
            }
            octet = (octet * 10) + (str[1] - '0');
            if (!isdigit(str[2]))
            {
                len = 2;
                return octet;
            }
            octet = (octet * 10) + (str[2] - '0');
            len = 3;
            return octet;
        }

        int hexWord(const char *str, int &len) const
        {
            const char *hex = "0123456789abcdef";
            int octet = 0;
            if (!isxdigit(str[0]))
            {
                len = 0;
                return -1;
            }
            octet = strchr(hex, tolower(str[0])) - hex;
            if (!isxdigit(str[1]))
            {
                len = 1;
                return octet;
            }
            octet = (octet * 16) + (strchr(hex, tolower(str[1])) - hex);
            if (!isxdigit(str[2]))
            {
                len = 2;
                return octet;
            }
            octet = (octet * 16) + (strchr(hex, tolower(str[2])) - hex);
            if (!isxdigit(str[3]))
            {
                len = 3;
                return octet;
            }
            octet = (octet * 16) + (strchr(hex, tolower(str[3])) - hex);
            len = 4;
            return octet;
        }

        bool isIpV4(const std::string &host) const
        {
            int octet, len, count = 0;
            size_t off = 0;

            while (true)
            {
                ++count;

                octet = decOctet(host.c_str() + off, len);
                if (octet < 0 || octet > 255)
                    return false;
                off += len;

                if (count == 4)
                    break;

                if (host[off++] != '.')
                    return false;
            }

            return off == host.size();
        }

        bool isIpV6_end(const std::string &host) const
        {
            int value, len;
            size_t off = 0;

            value = hexWord(host.c_str() + off, len);
            off += len;
            if (value < 0 || off == host.size() || host[off++] != ':')
                return false;

            value = hexWord(host.c_str() + off, len);
            off += len;
            if (value < 0)
                return false;

            return off == host.size();
        }

        bool isIpV6(const std::string &host) const
        {
            int value, len, group = 8;
            bool has_double = false;
            size_t off = 0;

            if (host.size() < 2)
                return 0;

            if (host[0] == ':')
            {
                if (host[1] != ':')
                    return false; // Starts with single colon, invalid

                has_double = true;
                --group;
                off += 2;
            }

            while (off < host.size() && host[off] != ':')
            {
                if (((has_double && group > 2) || group == 2) && isIpV4(host.substr(off)))
                    return true;

                value = hexWord(host.c_str() + off, len);
                off += len;
                if (value < 0)
                    break;
                --group;
                if (group > 0 && off < host.size() && host[off++] != ':')
                    return false;
            }

            if (off == host.size() && host[off-1] == ':' && host[off-2] != ':') // Unexpected end-of-string
                return false;

            if (group > 0 && off < host.size() && host[off] == ':') // Found double colon
            {
                if (has_double) // Already had a double colon
                    return false;

                has_double = true;
                --group;
                ++off;
            }

            while (off < host.size() && host[off] != ':')
            {
                if (((has_double && group > 2) || group == 2) && isIpV4(host.substr(off)))
                    return true;

                value = hexWord(host.c_str() + off, len);
                off += len;
                if (value < 0)
                    return false;
                --group;
                if (group > 0 && off < host.size() && host[off++] != ':')
                    return false;
            }

            if (off != host.size() || (group > 0 && !has_double))
                return false;

            if (host[off-1] == ':' && host[off-2] != ':') // Unexpected end-of-string
                return false;

            return true;
        }

        bool isIpFuture(const std::string &host) const
        {
            static const char *unreserved = "_-.~";
            static const char *sub_delims = "!$&'()*+,;=";
            size_t i;

            if (host.size() < 3 || host[0] != 'v' || !isxdigit(host[1]))
                return false;

            for (i = 2; i < host.size() && isxdigit(host[i]); ++i);

            if (i + 1 >= host.size() || host[i++] != '.')
                return false;

            for (; i < host.size(); ++i)
            {
                if (!isalnum(host[i]) && host[i] != ':' && strchr(unreserved, host[i]) == NULL &&
                        strchr(sub_delims, host[i]) == NULL)
                    return false;
            }

            return true;
        }

        bool isIpLiteral(std::string host) const
        {
            if (host.size() < 2)
                return false;
            if (host[0] != '[' || host[host.size()-1] != ']')
                return false;
            host.erase(0, 1);
            host.erase(host.size() - 1);
            return isIpV6(host) || isIpFuture(host);
        }

        bool isIpAddr(const std::string &host) const
        {
            return isIpV4(host) || isIpLiteral(host);
        }

    public:
        enum ParseMode
        {
            TolerantMode,
            ExactMode
        };

        static std::string toPercentEncoding(std::string uri)
        {
            static const char *dig = "0123456789abcdef";
            for (size_t i = 0; i < uri.size(); ++i)
            {
                if (!isalpha(uri[i]) && !isdigit(uri[i]) && uri[i] != '-' && uri[i] != '_' &&
                        uri[i] != '.' && uri[i] != '~')
                {
                    unsigned int c = uri[i] & 0xFF;
                    uri.replace(i, 1, std::string("%") + dig[c >> 4] + dig[c & 0xf]);
                    i += 2;
                }
            }

            return uri;
        }

        static std::string fromPercentEncoding(std::string uri)
        {
            static const char *dig = "0123456789abcdef";
            for (size_t i = 0; i+2 < uri.size(); ++i)
            {
                if (uri[i] == '%' && isxdigit(uri[i+1]) && isxdigit(uri[i+2]))
                {
                    unsigned int c;
                    c = strchr(dig, tolower(uri[i+1])) - dig;
                    c <<= 4;
                    c += strchr(dig, tolower(uri[i+2])) - dig;
                    uri.replace(i, 3, 1, c);
                }
            }

            return uri;
        }

        static std::string tolerantEncode(std::string uri)
        {
            bool flag = false;
            for (size_t i = 0; i+2 < uri.size(); ++i)
            {
                if (uri[i] == '%' && !(isxdigit(uri[i+1]) || isxdigit(uri[i+2])))
                {
                    flag = true;
                    break;
                }
            }
            if (flag) boost::replace_all(uri, "%", "%25"); // Escape all percent symbols

            static const char *escape = "\"<>\\^`{|}\x7F";
            static const char *dig = "0123456789abcdef";
            for (size_t i = 0; i < uri.size(); ++i) // Escape reserved characters
            {
                if (uri[i] <= 0x20 || (uri[i] & 0xFF) >= 0x80 || strchr(escape, uri[i]) != NULL)
                {
                    unsigned int c = uri[i] & 0xFF;
                    uri.replace(i, 1, std::string("%") + dig[c >> 4] + dig[c & 0xf]);
                    i += 2;
                }
            }

            return uri;
        }

        static Uri fromString(std::string uri, ParseMode mode = TolerantMode)
        {
            Uri result;
            size_t start = 0, len = uri.find(':');
            if (mode == TolerantMode)
                uri = tolerantEncode(uri);
            result.scheme_ = uri.substr(start, len);
            start = len+1;
            if (uri.substr(start, 2) == "//") // Authority part present
            {
                size_t slash_idx = uri.find('/', start += 2);
                size_t at_idx = uri.find('@', start);

                result.dual_slash_ = true;

                if (slash_idx == std::string::npos) slash_idx = uri.size();
                if (at_idx == std::string::npos) at_idx = uri.size();

                if (at_idx < slash_idx) // Authentication part present
                {
                    result.username_ = uri.substr(start, at_idx-start);
                    size_t colon_idx = result.username_.find(':');
                    if (colon_idx != std::string::npos)
                    {
                        result.password_ = result.username_.substr(colon_idx+1);
                        result.username_.erase(colon_idx, std::string::npos);
                    }
                    start = at_idx+1;
                }

                // Host must be present, with optional port
                result.host_ = uri.substr(start, slash_idx-start);
                start = result.host_.find_last_of(':');
                len = result.host_.find_last_of(']');
                if (start != std::string::npos && (len == std::string::npos || len < start))
                {
                    try {
                        result.port_ = boost::lexical_cast<int>(result.host_.substr(start+1));
                    } catch (std::exception &) {
                        result.port_ = -1;
                    }
                    result.host_.erase(start, std::string::npos);
                }
                start = slash_idx;
            }

            // Extract path, parsing query and fragment as necessary
            std::string *s;
            result.path_ = uri.substr(start);
            start = result.path_.find('?');
            if (start != std::string::npos)
            {
                result.fragment_ = result.query_ = result.path_.substr(start+1);
                result.path_.erase(start, std::string::npos);
                s = &result.query_;
            }
            else
            {
                result.fragment_ = result.path_;
                s = &result.path_;
            }
            start = result.fragment_.find('#');
            if (start != std::string::npos)
            {
                s->erase(start, std::string::npos);
                result.fragment_.erase(0, start+1);
            }
            else
                result.fragment_.clear();
            return result;
        }

        static Uri fromString(const char *uri, ParseMode mode = TolerantMode)
        {
            return fromString(std::string(uri), mode);
        }

        void swap(Uri &other)
        {
            std::swap(scheme_, other.scheme_);
            std::swap(host_, other.host_);
            std::swap(path_, other.path_);
            std::swap(query_, other.query_);
            std::swap(fragment_, other.fragment_);
            std::swap(dual_slash_, other.dual_slash_);
            std::swap(port_, other.port_);
            std::swap(username_, other.username_);
            std::swap(password_, other.password_);
        }

        Uri() : dual_slash_(false), port_(-1) {}
        Uri(const std::string &uri, ParseMode mode = TolerantMode) {*this = fromString(uri, mode);}
        Uri(const char *uri, ParseMode mode = TolerantMode) {*this = fromString(uri, mode);}

        void clear() {*this = Uri();}

        const std::string &scheme() const {return scheme_;}
        const std::string &host() const {return host_;}
        const std::string &path() const {return path_;}
        const std::string &query() const {return query_;}
        const std::string &fragment() const {return fragment_;}
        const std::string &username() const {return username_;}
        const std::string &password() const {return password_;}
        int port(int defaultPort = -1) const {return port_ >= 0? port_: defaultPort;}

        // Additional getter helpers (not guaranteed to return valid URL data unless isValid() returns true)
        std::string userInfo() const {return username_.empty()? "": password_.empty()? username_: username_ + ":" + password_;}
        std::string topLevel() const {return scheme_ + "://" + hostAndPort();}
        std::string hostAndPort() const {return port_ < 0? host_: host_ + ":" + boost::lexical_cast<std::string>(port_);}
        bool hasAuthority() const {return dual_slash_ || !username_.empty() || !host_.empty() || port_ >= 0;}
        std::string authority() const {return username_.empty()? hostAndPort(): userInfo() + "@" + hostAndPort();}
        std::string uriPath() const {return hasAuthority() && path_.empty()? "/": path_;}
        std::string uriQuery() const {return !query_.empty() && query_[0] != '?'? "?" + query_: query_;}
        std::string uriFragment() const {return !fragment_.empty() && fragment_[0] != '#'? "#" + fragment_: fragment_;}
        std::string uriPathAndQueryAndFragment() const {return uriPath() + uriQuery() + uriFragment();}
        std::string pathAndQueryAndFragment() const {return path_ + uriQuery() + uriFragment();}

        // Will convert the internally represented URL to a string, without
        // scheme-sensitive error-handling.
        std::string toStringRaw(bool require_dual_slash = false) const
        {
            bool authority_present = false;
            std::string url = scheme_ + ":";
            if (dual_slash_ || require_dual_slash || !username_.empty() || !host_.empty() || port_ >= 0)
            {
                url += "//";
                authority_present = true;
            }
            if (!username_.empty())
            {
                url += username_;
                if (!password_.empty())
                    url += ":" + password_;
                url += "@";
            }
            url += host_;
            if (port_ >= 0)
                url += ":" + boost::lexical_cast<std::string>(port_);
            if (authority_present && !path_.empty() && path_.at(0) != '/')
                url += "/";
            url += path_;
            if (!query_.empty() && query_[0] != '?')
                url += "?";
            url += query_;
            if (!fragment_.empty() && fragment_[0] != '#')
                url += "#";
            url += fragment_;
            return url;
        }

        // Will convert the internally represented URL to a string, with
        // scheme-sensitive format
        // Schemes supported: file, ftp, http, https, ldap
        std::string toString() const
        {
            std::string lscheme = boost::to_lower_copy(scheme_);

            if (lscheme == "file" ||
                lscheme == "ftp" ||
                lscheme == "http" ||
                lscheme == "https" ||
                lscheme == "ldap")
                return toStringRaw(true);

            return toStringRaw(false);
        }

        void setScheme(const std::string &scheme) {this->scheme_ = scheme;}
        void setHost(const std::string &host, ParseMode mode = TolerantMode)
        {
            if (mode == TolerantMode)
                host_ = tolerantEncode(host);
            else
                host_ = host;
        }
        void setPath(const std::string &path, ParseMode mode = TolerantMode)
        {
            if (mode == TolerantMode)
                path_ = tolerantEncode(path);
            else
                path_ = path;
        }
        void setQuery(const std::string &query, ParseMode mode = TolerantMode)
        {
            if (mode == TolerantMode)
                query_ = tolerantEncode(query);
            else
                query_ = query;
        }
        void setFragment(const std::string &fragment, ParseMode mode = TolerantMode)
        {
            if (mode == TolerantMode)
                fragment_ = tolerantEncode(fragment);
            else
                fragment_ = fragment;
        }
        void setUsername(const std::string &username, ParseMode mode = TolerantMode)
        {
            if (mode == TolerantMode)
                username_ = tolerantEncode(username);
            else
                username_ = username;
        }
        void setPassword(const std::string &password, ParseMode mode = TolerantMode)
        {
            if (mode == TolerantMode)
                password_ = tolerantEncode(password);
            else
                password_ = password;
        }
        void setUserInfo(const std::string &userInfo, ParseMode mode = TolerantMode)
        {
            if (mode == TolerantMode)
                username_ = tolerantEncode(userInfo);
            else
                username_ = userInfo;
            size_t idx = username_.find(':');
            if (idx != std::string::npos)
            {
                password_ = username_.substr(idx+1);
                username_.erase(0, idx);
            }
            else
                password_.clear();
        }
        void setPort(int port) {port_ = port;}
        void clearPort() {port_ = -1;}

        bool isValid() const
        {
            static const char *unreserved = "_-.~";
            static const char *sub_delims = "!$&'()*+,;=";
            bool authority_present = dual_slash_ || !username_.empty() || !host_.empty() || port_ >= 0;

            // Test scheme
            if (!scheme_.empty() && !isalpha(scheme_[0]))
            {
#ifdef URL_DEBUG
                std::cout << "URL: Scheme failed\n";
#endif
                return false;
            }
            for (size_t i = 1; i < scheme_.size(); ++i)
                if (!isalnum(scheme_[i]) && scheme_[i] != '+' && scheme_[i] != '-' && scheme_[i] != '.')
                {
#ifdef URL_DEBUG
                    std::cout << "URL: Scheme failed\n";
#endif
                    return false;
                }

            // Test host
            if (!isIpAddr(host_))
            {
                for (size_t i = 0; i < host_.size(); ++i)
                {
                    if (host_[i] == '%' && (i+2 >= host_.size() || !isxdigit(host_[i+1]) || !isxdigit(host_[i+2])))
                    {
#ifdef URL_DEBUG
                        std::cout << "URL: Host failed\n";
#endif
                        return false;
                    }
                    if (!isalnum(host_[i]) && host_[i] != '%' && strchr(unreserved, host_[i]) == NULL &&
                            strchr(sub_delims, host_[i]) == NULL)
                    {
#ifdef URL_DEBUG
                        std::cout << "URL: Host failed\n";
#endif
                        return false;
                    }
                }
            }

            // Test user info
            if (username_.empty() && !password_.empty())
            {
#ifdef URL_DEBUG
                std::cout << "URL: User Info failed\n";
#endif
                return false;
            }

            for (size_t i = 0; i < username_.size(); ++i)
            {
                if (username_[i] == '%' && (i+2 >= username_.size() || !isxdigit(username_[i+1]) || !isxdigit(username_[i+2])))
                {
#ifdef URL_DEBUG
                    std::cout << "URL: User Info failed\n";
#endif
                    return false;
                }
                if (!isalnum(username_[i]) && username_[i] != '%' && username_[i] != ':' &&
                        strchr(unreserved, username_[i]) == NULL && strchr(sub_delims, username_[i]) == NULL)
                {
#ifdef URL_DEBUG
                    std::cout << "URL: User Info failed\n";
#endif
                    return false;
                }
            }

            for (size_t i = 0; i < password_.size(); ++i)
            {
                if (password_[i] == '%' && (i+2 >= password_.size() || !isxdigit(password_[i+1]) || !isxdigit(password_[i+2])))
                {
#ifdef URL_DEBUG
                    std::cout << "URL: User Info failed\n";
#endif
                    return false;
                }
                if (!isalnum(password_[i]) && password_[i] != '%' && password_[i] != ':' &&
                        strchr(unreserved, password_[i]) == NULL && strchr(sub_delims, password_[i]) == NULL)
                {
#ifdef URL_DEBUG
                    std::cout << "URL: User Info failed\n";
#endif
                    return false;
                }
            }

            // Test path
            if (authority_present && !path_.empty() && path_[0] != '/')
            {
#ifdef URL_DEBUG
                std::cout << "URL: Path failed\n";
#endif
                return false;
            }
            else if (!authority_present && path_.substr(0, 2) == "//")
            {
#ifdef URL_DEBUG
                std::cout << "URL: Path failed\n";
#endif
                return false;
            }

            for (size_t i = 0; i < path_.size(); ++i)
            {
                if (path_[i] == '%' && (i+2 >= path_.size() || !isxdigit(path_[i+1]) || !isxdigit(path_[i+2])))
                {
#ifdef URL_DEBUG
                    std::cout << "URL: Path failed\n";
#endif
                    return false;
                }
                if (!isalnum(path_[i]) && path_[i] != '/' && path_[i] != '%' && path_[i] != ':' && path_[i] != '@' &&
                        strchr(unreserved, path_[i]) == NULL && strchr(sub_delims, path_[i]) == NULL)
                {
#ifdef URL_DEBUG
                    std::cout << "URL: Path failed\n";
#endif
                    return false;
                }
            }

            // Test query
            for (size_t i = (!query_.empty() && query_[0] == '?'); i < query_.size(); ++i)
            {
                if (query_[i] == '%' && (i+2 >= query_.size() || !isxdigit(query_[i+1]) || !isxdigit(query_[i+2])))
                {
#ifdef URL_DEBUG
                    std::cout << "URL: Query failed\n";
#endif
                    return false;
                }
                if (!isalnum(query_[i]) && query_[i] != '%' && query_[i] != ':' && query_[i] != '@' &&
                        query_[i] != '/' && query_[i] != '?' && strchr(unreserved, query_[i]) == NULL && strchr(sub_delims, query_[i]) == NULL)
                {
#ifdef URL_DEBUG
                    std::cout << "URL: Query failed\n";
#endif
                    return false;
                }
            }

            // Test fragment
            for (size_t i = (!fragment_.empty() && fragment_[0] == '#'); i < fragment_.size(); ++i)
            {
                if (fragment_[i] == '%' && (i+2 >= fragment_.size() || !isxdigit(fragment_[i+1]) || !isxdigit(fragment_[i+2])))
                {
#ifdef URL_DEBUG
                    std::cout << "URL: Fragment failed\n";
#endif
                    return false;
                }
                if (!isalnum(fragment_[i]) && fragment_[i] != '%' && fragment_[i] != ':' && fragment_[i] != '@' &&
                        fragment_[i] != '/' && fragment_[i] != '?' && strchr(unreserved, fragment_[i]) == NULL && strchr(sub_delims, fragment_[i]) == NULL)
                {
#ifdef URL_DEBUG
                    std::cout << "URL: Fragment failed\n";
#endif
                    return false;
                }
            }

            return !(scheme_.empty() && host_.empty() && username_.empty() && password_.empty() &&
                     port_ < 0 && path_.empty() && query_.empty() && fragment_.empty());
        }

    private:
        /*
         *     scheme - The scheme of the URL request (i.e. http, file, mailto, etc.)
         *       host - The server name or address (i.e. localhost, www.example.com, 192.0.0.1, etc.)
         * dual_slash - Whether the scheme should have two slashes. Defaults to false,
         *              unless present in parsed URL.
         *       path - The path requested by the URL. Should always start with '/' if host is present.
         *      query - The query requested by the URL. Should always start with '?' if used but empty.
         *   fragment - The fragment requested by the URL. Should always start with '#' if used but empty.
         *       port - The port of the host to connect to. Should always be -1 if not used.
         *   username - The username of the URL. Empty if unused.
         *   password - The password of the URL. Empty if unused.
         *
         */

        std::string scheme_, host_, path_, query_, fragment_;
        bool dual_slash_;
        int port_;
        std::string username_, password_;
    };

    namespace Http
    {
        typedef std::map<std::string, std::string> Headers;

        enum StatusCode
        {
            Invalid,

            Informational = 1,
            Success = 2,
            Redirect = 3,
            ClientError = 4,
            ServerError = 5,

            // Informational
            I_Continue = 100,
            I_SwitchingProtocols = 101,
            I_Processing = 102,

            // Success
            S_Ok = 200,
            S_Created = 201,
            S_Accepted = 202,
            S_NonAuthoritativeInfo = 203,
            S_NoContent = 204,
            S_ResetContent = 205,
            S_PartialContent = 206,
            S_MultiStatus = 207,
            S_AlreadyReported = 208,
            S_ImUsed = 209,

            // Redirect
            R_MultipleChoices = 300,
            R_MovedPermanently = 301,
            R_Found = 302,
            R_SeeOther = 303,
            R_NotModified = 304,
            R_UseProxy = 305,
            R_SwitchProxy = 306,
            R_TemporaryRedirect = 307,
            R_PermanentRedirect = 308,

            // Client error
            E_BadRequest = 400,
            E_Unauthorized = 401,
            E_PaymentRequired = 402,
            E_Forbidden = 403,
            E_NotFound = 404,
            E_MethodNotAllowed = 405,
            E_NotAcceptable = 406,
            E_ProxyAuthenticationRequired = 407,
            E_RequestTimeout = 408,
            E_Conflict = 409,
            E_Gone = 410,
            E_LengthRequired = 411,
            E_PreconditionFailed = 412,
            E_PayloadTooLarge = 413,
            E_UriTooLong = 414,
            E_UnsupportedMediaType = 415,
            E_RangeNotSatisfiable = 416,
            E_ExpectationFailed = 417,
            E_ImATeapot = 418,
            E_MisdirectedRequest = 421,
            E_UnprocessableEntity = 422,
            E_Locked = 423,
            E_FailedDependency = 424,
            E_UpgradeRequired = 426,
            E_PreconditionRequired = 428,
            E_TooManyRequests = 429,
            E_RequestHeaderFieldsTooLarge = 431,
            E_UnavailableForLegalReasons = 451,

            // Server error
            V_InternalServerError = 500,
            V_NotImplemented = 501,
            V_BadGateway = 502,
            V_ServiceUnavailable = 503,
            V_GatewayTimeout = 504,
            V_HttpVersionNotSupported = 505,
            V_VariantAlsoNegotiates = 506,
            V_InsufficientStorage = 507,
            V_LoopDetected = 508,
            V_NotExtended = 510,
            V_NetworkAuthenticationRequired = 511
        };

        class Request
        {
        public:
            Request(const Uri &url = Uri(),
                    const std::string &body = std::string(),
                    const Headers &headers = Headers(),
                    boost::posix_time::time_duration timeout = boost::posix_time::pos_infin,
                    bool lcaseHeaders = true)
                : url_(url)
                , body_(body)
                , istream_(NULL)
                , ostream_(NULL)
                , headers_(headers)
                , timeout_(timeout)
                , lcase_headers_(lcaseHeaders)
            {}
            // Request does NOT take ownership of stream
            Request(const Uri &url,
                    std::ostream *output_stream,
                    const std::string &body = std::string(),
                    const Headers &headers = Headers(),
                    boost::posix_time::time_duration timeout = boost::posix_time::pos_infin,
                    bool lcaseHeaders = true)
                : url_(url)
                , body_(body)
                , istream_(NULL)
                , ostream_(output_stream)
                , headers_(headers)
                , timeout_(timeout)
                , lcase_headers_(lcaseHeaders)
            {}
            // Request does NOT take ownership of streams
            Request(const Uri &url,
                    std::istream *input_stream,
                    std::ostream *output_stream,
                    const Headers &headers = Headers(),
                    boost::posix_time::time_duration timeout = boost::posix_time::pos_infin,
                    bool lcaseHeaders = true)
                : url_(url)
                , body_()
                , istream_(input_stream)
                , ostream_(output_stream)
                , headers_(headers)
                , timeout_(timeout)
                , lcase_headers_(lcaseHeaders)
            {}
            // Request does NOT take ownership of stream
            Request(const Uri &url,
                    std::istream *input_stream,
                    const Headers &headers = Headers(),
                    boost::posix_time::time_duration timeout = boost::posix_time::pos_infin,
                    bool lcaseHeaders = true)
                : url_(url)
                , body_()
                , istream_(input_stream)
                , ostream_(NULL)
                , headers_(headers)
                , timeout_(timeout)
                , lcase_headers_(lcaseHeaders)
            {}
            Request(const Uri &url,
                    const Headers &headers,
                    boost::posix_time::time_duration timeout = boost::posix_time::pos_infin,
                    bool lcaseHeaders = true)
                : url_(url)
                , body_()
                , istream_(NULL)
                , ostream_(NULL)
                , headers_(headers)
                , timeout_(timeout)
                , lcase_headers_(lcaseHeaders)
            {}
            Request(const Uri &url,
                    boost::posix_time::time_duration timeout,
                    bool lcaseHeaders = true)
                : url_(url)
                , body_()
                , istream_(NULL)
                , ostream_(NULL)
                , headers_()
                , timeout_(timeout)
                , lcase_headers_(lcaseHeaders)
            {}

            const Uri &url() const {return url_;}
            Uri &url() {return url_;}

            const std::string &body() const {return body_;}
            std::string &body() {return body_;}

            std::istream *istream() const {return istream_;}
            std::ostream *ostream() const {return ostream_;}

            const Headers &headers() const {return headers_;}
            Headers &headers() {return headers_;}

            const boost::posix_time::time_duration &timeout() const {return timeout_;}
            boost::posix_time::time_duration &timeout() {return timeout_;}

            bool lowercaseHeaderNames() const {return lcase_headers_;}
            bool &lowercaseHeaderNames() {return lcase_headers_;}

            void setUrl(const Uri &url) {url_ = url;}

            void setBody(const std::string &body) {body_ = body;}

            // Request does NOT take ownership of stream
            void setInputStream(std::istream *stream) {istream_ = stream;}
            void setOutputStream(std::ostream *stream) {ostream_ = stream;}

            void setHeaders(const Headers &headers) {headers_ = headers;}

            void setTimeout(boost::posix_time::time_duration timeout) {timeout_ = timeout;}

            void setLowercaseHeaderNames(bool b) {lcase_headers_ = b;}

        private:
            Uri url_;
            std::string body_;
            mutable std::istream *istream_;
            mutable std::ostream *ostream_;
            Headers headers_;
            boost::posix_time::time_duration timeout_;
            bool lcase_headers_;
        };

        class Response
        {
        public:
            Response() : code_(Invalid), group_(Invalid) {}

            bool isInformational() const {return group_ == 1;}
            bool isSuccess() const {return group_ == 2;}
            bool isRedirect() const {return group_ == 3;}
            bool isError() const {return group_ >= 4 || group_ == Invalid;}

            StatusCode code() const {return code_;}
            StatusCode &code() {return code_;}

            StatusCode group() const {return group_;}
            StatusCode &group() {return group_;}

            const std::string &message() const {return message_;}
            std::string &message() {return message_;}

            const Headers &headers() const {return headers_;}
            Headers &headers() {return headers_;}

            const std::string &body() const {return body_;}
            std::string &body() {return body_;}

            void setCode(StatusCode code) {code_ = code;}

            void setGroup(StatusCode group) {group_ = group;}

            void setMessage(const std::string &message) {message_ = message;}

            void setHeaders(const Headers &headers) {headers_ = headers;}

            void setBody(const std::string &body) {body_ = body;}

        private:
            StatusCode code_, group_;
            std::string message_;

            Headers headers_;
            std::string body_;
        };

        class Connection : public boost::noncopyable
        {
        protected:
            void raise_error(const boost::system::error_code &err)
            {
                ec = err;
                emessage = "Error: " + err.message();
                response_ = Response();
                response_.setMessage(emessage);
            }
            void raise_error(const boost::system::error_code &err, const std::string &message)
            {
                ec = err;
                emessage = message;
                response_ = Response();
                response_.setMessage(message);
            }

            void clear_buffers()
            {
                request_buf.prepare(request_buf.size());
                request_buf.commit(request_buf.size());
                request_buf.consume(request_buf.size());
                response_buf.consume(response_buf.size());
            }

            bool do_not_poll;

        public:
            typedef boost::function<void (Connection &c)> DestructorHandler;
            typedef boost::function<void (Connection &c, const boost::system::error_code &err)> BasicHandler;
            typedef boost::function<void (Connection &c, const Request &, const boost::system::error_code &err)> RequestHandler;
            typedef boost::function<void (Connection &c, const Response &, const boost::system::error_code &err)> ResponseHandler;
#ifdef ENABLE_SSL
            typedef boost::function<bool (Connection &c, bool preverified, boost::asio::ssl::verify_context &ctx)> VerifyHandler;
#endif
            // Progress handlers set total to UINT64_MAX if unknown
            typedef boost::function<void (Connection &c, uint64_t just_received, uint64_t total_received, uint64_t total)> ProgressHandler;
            typedef BasicHandler ConnectHandler, DisconnectHandler;
            typedef ProgressHandler UploadProgressHandler, DownloadProgressHandler;

            // Partial response callback modes:
            enum ResponseType
            {
                ResponseWhole, // Only return entire response
                ResponseLine, // Return every line of response separately
                ResponseAny // Return whatever is available, always a chunk for chunked encoding, and anything in the buffer otherwise
            };

            enum TimeoutMode
            {
                TimeoutPerOperation, // Timeout for resolve, connect, read, or write individually
                TimeoutPerTransaction // Timeout for entire connect or request/response transaction
            };

            static void DefaultConnectHandler(Connection &c, const boost::system::error_code &err)
            {
                if (!err)
                    c.sendRequest();
                else
                {
                    c.cancel_wait_for_transaction();
                    c.cancel_wait_for_disconnect();
                }
            }

            Connection(const boost::posix_time::time_duration &timeout = boost::posix_time::pos_infin)
                : do_not_poll(false)
                , connect_callback(DefaultConnectHandler)
                , disconnect_callback()
                , request_callback()
                , response_callback()
                , partial_response_callback()
                , destructor_callback()
#ifdef ENABLE_SSL
                , verify_callback()
#endif
                , upload_progress_callback()
                , download_progress_callback()
                , partial_response_type(ResponseWhole)
                , in_progress(false)
                , resolver_(io_serv)
#ifdef ENABLE_SSL
                , sock_ctx()
                , sock_secure(false)
                , ssock()
#endif
                , sock()
                , running_(false)
                , reconnect_if_aborted(false)
                , reconnecting_(false)
                , connect_work()
                , connection_work()
                , transaction_work()
                , timeout_mode_(TimeoutPerOperation)
                , timeout_(timeout)
                , deadline_(io_serv)
                , deadline_running_(false)
            {
            }
            Connection(const Uri &url, const boost::posix_time::time_duration &timeout = boost::posix_time::pos_infin)
                : do_not_poll(false)
                , connect_callback(DefaultConnectHandler)
                , disconnect_callback()
                , request_callback()
                , response_callback()
                , partial_response_callback()
                , destructor_callback()
#ifdef ENABLE_SSL
                , verify_callback()
#endif
                , upload_progress_callback()
                , download_progress_callback()
                , partial_response_type(ResponseWhole)
                , in_progress(false)
                , resolver_(io_serv)
#ifdef ENABLE_SSL
                , sock_ctx()
                , sock_secure(false)
                , ssock()
#endif
                , sock()
                , running_(false)
                , reconnect_if_aborted(false)
                , reconnecting_(false)
                , connect_work()
                , connection_work()
                , transaction_work()
                , timeout_mode_(TimeoutPerOperation)
                , timeout_(timeout)
                , deadline_(io_serv)
                , deadline_running_(false)
            {
                connect(url);
            }
            Connection(const Request &request, const boost::posix_time::time_duration &timeout = boost::posix_time::pos_infin)
                : do_not_poll(false)
                , connect_callback(DefaultConnectHandler)
                , disconnect_callback()
                , request_callback()
                , response_callback()
                , partial_response_callback()
                , destructor_callback()
#ifdef ENABLE_SSL
                , verify_callback()
#endif
                , upload_progress_callback()
                , download_progress_callback()
                , partial_response_type(ResponseWhole)
                , in_progress(false)
                , resolver_(io_serv)
#ifdef ENABLE_SSL
                , sock_ctx()
                , sock_secure(false)
                , ssock()
#endif
                , sock()
                , running_(false)
                , reconnect_if_aborted(false)
                , reconnecting_(false)
                , connect_work()
                , connection_work()
                , transaction_work()
                , timeout_mode_(TimeoutPerOperation)
                , timeout_(timeout)
                , deadline_(io_serv)
                , deadline_running_(false)
            {
                connect(request);
            }
            ~Connection()
            {
                disconnectImmediately();
                if (!destructor_callback.empty())
                {
                    do_not_poll = true;
                    destructor_callback(*this);
                    do_not_poll = false;
                }
            }

            bool handlingCallback() const {return do_not_poll;}
            bool connecting() const {return connect_work != NULL;}
            bool reconnecting() const {return reconnecting_;}
            bool inTransaction() const {return transaction_work != NULL;}

            void reconnectOnConnAborted(bool b = true) {reconnect_if_aborted = b;}

            // The connect() functions connect asynchronously to a server,
            // and invoke the connect handler to signal success or failure.
            // The connection is initiated once start() is called. Return true on
            // successful initiation, false on failure.
            bool connect(const Request &request)
            {
                setRequest(request);
                return connect();
            }

            bool connect(const Request &request, ConnectHandler handler)
            {
                setRequest(request);
                setConnectHandler(handler);
                return connect();
            }

            bool connect(const Uri &uri, ConnectHandler handler)
            {
                setConnectHandler(handler);
                return connect(uri);
            }

            bool connect(const Uri &uri)
            {
                request_ = Request(uri);
                return connect();
            }

            bool connect()
            {
                disconnect();

                if (!request_.url().isValid())
                {
                    raise_error(boost::asio::error::invalid_argument,
                                "Invalid URL in client");
                    if (!connect_callback.empty())
                    {
                        do_not_poll = true;
                        connect_callback(*this, ec);
                        do_not_poll = false;
                    }
                    return false;
                }

                topLevel_ = request_.url().topLevel();
                host_ = request_.url().host();
                service_ = request_.url().port() < 0? request_.url().scheme(): boost::lexical_cast<std::string>(request_.url().port());
#ifdef ENABLE_SSL
                sock_secure = "https" == boost::to_lower_copy(request_.url().scheme());
#endif
                try
                {
                    tcp::resolver::query query(host_, service_,
                                               boost::asio::ip::resolver_query_base::canonical_name);
#ifdef ENABLE_SSL
                    if (sock_secure)
                    {
                        if (!sock_ctx)
                            throw boost::asio::error::invalid_argument;

                        ssock.reset(new boost::asio::ssl::stream<tcp::socket>(io_serv, *sock_ctx));

                        ssock->set_verify_callback(boost::bind(&Connection::verify_certificate, this, _1, _2));
                    }
                    else
#endif
                        sock.reset(new tcp::socket(io_serv));

                    deadline_.expires_from_now(timeout_);

                    resolver_.async_resolve(query, boost::bind(&Connection::handle_resolve, this,
                                                               boost::asio::placeholders::error,
                                                               boost::asio::placeholders::iterator));

                    connect_work.reset(new boost::asio::io_service::work(io_serv));

                    start_timeout();
                }
                catch (boost::system::system_error &e)
                {
                    stop_timeout();
#ifdef ENABLE_SSL
                    sock_secure = false;
                    ssock.reset();
#endif
                    sock.reset();
                    connect_work.reset();
                    connection_work.reset();
                    transaction_work.reset();
                    topLevel_.clear();
                    host_.clear();
                    service_.clear();
                    raise_error(e.code(), e.what());
                    return false;
                }

#ifdef ENABLE_SSL
                sock_secure = false;
#endif
                running_ = true;
                clearError();

                return true;
            }

            // Immediately disconnects this client from the server.
            // Suitable for use in handler callbacks.
            void disconnectImmediately()
            {
                disconnect_internal(true);
            }

            // Disconnects this client from the server. This is not necessarily done immediately.
            // Use wait_for_disconnect() or a disconnect handler for the true end of the connection.
            // If immediate disconnection is needed, use disconnectImmediately().
            // DO NOT CALL FROM A HANDLER! Use disconnectImmediately() in the handler instead.
            void disconnect()
            {
                disconnect_internal(false);
            }

            // Blocks until the connection is connected
            // Cannot be invoked in any handler
            void wait_for_connect()
            {
                if (io_serv.stopped())
                    io_serv.reset();
                if (!connect_work && !running_)
                    connect_work.reset(new boost::asio::io_service::work(io_serv));
                io_serv.run();
            }
            void wait_later_for_connect()
            {
                if (!connect_work && !running_)
                    connect_work.reset(new boost::asio::io_service::work(io_serv));
            }
            // Cancels the wait until the connection is connected
            // Can be invoked in a handler
            void cancel_wait_for_connect() {connect_work.reset();}
            // Blocks until the connection is disconnected
            // Cannot be invoked in any handler
            void wait_for_disconnect()
            {
                if (io_serv.stopped())
                    io_serv.reset();
                if (!connection_work && running_)
                    connection_work.reset(new boost::asio::io_service::work(io_serv));
                io_serv.run();
            }
            void wait_later_for_disconnect()
            {
                if (!connection_work && running_)
                    connection_work.reset(new boost::asio::io_service::work(io_serv));
            }
            // Cancels the wait until the connection is disconnected
            // Can be invoked in a handler
            void cancel_wait_for_disconnect() {connection_work.reset();}
            // Blocks until the transaction (request/response transfer) is complete
            // Cannot be invoked in any handler
            void wait_for_transaction()
            {
                if (io_serv.stopped())
                    io_serv.reset();
                if (!transaction_work && running_)
                    transaction_work.reset(new boost::asio::io_service::work(io_serv));
                io_serv.run();
            }
            void wait_later_for_transaction()
            {
                if (!transaction_work && running_)
                    transaction_work.reset(new boost::asio::io_service::work(io_serv));
            }
            // Cancels the wait until the transaction (request/response transfer) is complete
            // Can be invoked in a handler
            void cancel_wait_for_transaction() {transaction_work.reset();}

            // Starts the asynchronous jobs in this connection
            // Cannot be invoked in any handler
            size_t poll()
            {
                if (!do_not_poll)
                {
                    if (io_serv.stopped())
                        io_serv.reset();
                    return io_serv.poll();
                }
                return 0;
            }
            // Starts one asynchronous job in this connection
            // Cannot be invoked in any handler
            size_t poll_one()
            {
                if (!do_not_poll)
                {
                    if (io_serv.stopped())
                        io_serv.reset();
                    return io_serv.poll_one();
                }
                return 0;
            }
            // Starts one synchronous job in this connection (blocking)
            // Cannot be invoked in any handler
            size_t run_one()
            {
                if (!do_not_poll)
                {
                    if (io_serv.stopped())
                        io_serv.reset();
                    return io_serv.run_one();
                }
                return 0;
            }
            // Starts the synchronous jobs in this connection (blocking)
            // Cannot be invoked in any handler
            size_t run()
            {
                if (!do_not_poll)
                {
                    if (io_serv.stopped())
                        io_serv.reset();
                    return io_serv.run();
                }
                return 0;
            }
            // Stops the asynchronous jobs in this connection
            // Can be invoked in any handler
            void stop()
            {
                io_serv.stop();
            }

            const std::string &host() const {return host_;}
            const std::string &topLevelDomain() const {return topLevel_;}
            const std::string &service() const {return service_;}

            const Request &request() const {return request_;}
            Request &request() {return request_;}

            const std::string &httpMethod() const {return method;}
            std::string &httpMethod() {return method;}

            const Response &response() const {return response_;}

            const boost::asio::streambuf &request_streambuf() const {return request_buf;}
            boost::asio::streambuf &request_streambuf() {return request_buf;}

            const boost::asio::streambuf &response_streambuf() const {return response_buf;}
            boost::asio::streambuf &response_streambuf() {return response_buf;}

            const boost::asio::io_service &io_service() const {return io_serv;}
            boost::asio::io_service &io_service() {return io_serv;}

            bool connected() const
            {
                return (sock && sock->is_open())
#ifdef ENABLE_SSL
                        || (ssock && ssock->lowest_layer().is_open())
#endif
                        ;
            }
            bool disconnected() const {return !connected();}

            // The HTTP_METHOD() functions send a request immediately,
            // and this connection must already be connected to a server.
            // They return true on a successful request initiation, false
            // on failure.
            bool get() {return sendRequest("GET");}
            bool head() {return sendRequest("HEAD");}
            bool delete_() {return sendRequest("DELETE");}
            bool post() {return sendRequest("POST");}
            bool put() {return sendRequest("PUT");}

            bool get(const Request &request) {return sendRequest(request, "GET");}
            bool head(const Request &request) {return sendRequest(request, "HEAD");}
            bool delete_(const Request &request) {return sendRequest(request, "DELETE");}
            bool post(const Request &request) {return sendRequest(request, "POST");}
            bool put(const Request &request) {return sendRequest(request, "PUT");}

            bool get(const Uri &uri) {return sendRequest(uri, "GET");}
            bool head(const Uri &uri) {return sendRequest(uri, "HEAD");}
            bool delete_(const Uri &uri) {return sendRequest(uri, "DELETE");}
            bool post(const Uri &uri) {return sendRequest(uri, "POST");}
            bool put(const Uri &uri) {return sendRequest(uri, "PUT");}

            // The Later() functions set up a request for later,
            // and this connection does not need to be connected to a server.
            void getLater(const Request &request) {setRequest(request, "GET");}
            void headLater(const Request &request) {setRequest(request, "HEAD");}
            void delete_Later(const Request &request) {setRequest(request, "DELETE");}
            void postLater(const Request &request) {setRequest(request, "POST");}
            void putLater(const Request &request) {setRequest(request, "PUT");}

            void getLater(const Uri &uri) {setRequest(uri, "GET");}
            void headLater(const Uri &uri) {setRequest(uri, "HEAD");}
            void delete_Later(const Uri &uri) {setRequest(uri, "DELETE");}
            void postLater(const Uri &uri) {setRequest(uri, "POST");}
            void putLater(const Uri &uri) {setRequest(uri, "PUT");}

            // The setRequest()/setMethod() functions set up a request and optional method
            // for later and this connection does not need to be connected to a server.
            void setRequest(const Request &request)
            {
                if (!in_progress)
                    request_ = request;
            }

            void setRequest(const Uri &uri)
            {
                if (!in_progress)
                    request_ = Request(uri);
            }

            void setMethod(const std::string &method)
            {
                if (!in_progress)
                    this->method = method;
            }

            void setRequest(const Request &request, const std::string &method)
            {
                if (!in_progress)
                {
                    request_ = request;
                    this->method = method;
                }
            }

            void setRequest(const Uri &uri, const std::string &method)
            {
                if (!in_progress)
                {
                    request_ = Request(uri);
                    this->method = method;
                }
            }

            // The sendRequest() functions initiate sending a request once start() is called.
            // This connection must be connected to a server. All return true on
            // successful initiation of request, false on failure. Any arguments
            // left out will be retrieved from stored data. If the stored data
            // was not initialized with setRequest()/setMethod() functions, the
            // result is undefined.
            bool sendRequest()
            {
                return sendRequest(method);
            }

            bool sendRequest(const std::string &method)
            {
                return sendRequest(request_, method);
            }

            bool sendRequest(const Request &request, const std::string &method)
            {
                try
                {
                    std::string scheme = boost::to_lower_copy(request.url().scheme());
                    if (in_progress)
                    {
#ifdef NET_REQUEST_DEBUG
                        std::cout << "NETREQUEST: sendRequest(): request already in progress" << std::endl;
#endif
                        raise_error(boost::asio::error::already_connected);
                        return false;
                    }
                    else if (disconnected())
                    {
#ifdef NET_REQUEST_DEBUG
                        std::cout << "NETREQUEST: sendRequest(): disconnected" << std::endl;
#endif
                        raise_error(boost::asio::error::not_connected);
                        if (!request_callback.empty())
                        {
                            do_not_poll = true;
                            request_callback(*this, request, ec);
                            do_not_poll = false;
                        }
                        return false;
                    }
                    else if (
#ifdef ENABLE_SSL
                             (scheme == "https" && !sock_secure) ||
                             (scheme != "https" && sock_secure) ||
#endif
                             (scheme != "https" && scheme != "http"))
                    {
#ifdef NET_REQUEST_DEBUG
                        std::cout << "NETREQUEST: sendRequest(): invalid URL in client" << std::endl;
#endif
                        raise_error(boost::asio::error::invalid_argument, "Invalid URL in client");
                        if (!request_callback.empty())
                        {
                            do_not_poll = true;
                            request_callback(*this, request, ec);
                            do_not_poll = false;
                        }
                        return false;
                    }

                    in_progress = true;
                    this->method = boost::to_upper_copy(method);
                    request_ = request;
                    response_ = Response();

                    // Formulate request
                    std::ostream request_stream(&request_buf);
                    Headers lcase_headers;

                    for (Headers::const_iterator i = request_.headers().begin(); i != request_.headers().end(); ++i)
                        lcase_headers[boost::to_lower_copy(i->first)] = i->second;

                    request_stream << this->method << ' ' << request_.url().uriPathAndQueryAndFragment() << " HTTP/1.1\r\n";

                    for (Headers::const_iterator i = request_.headers().begin(); i != request_.headers().end(); ++i)
                        request_stream << i->first << ": " << i->second << "\r\n";

                    if (lcase_headers.find("accept") == lcase_headers.end())
                        request_stream << "Accept: *\r\n";

                    if ((!request_.body().empty() || request_.istream() != NULL) &&
                            lcase_headers.find("transfer-encoding") == lcase_headers.end())
                    {
                        if (!request_.body().empty() && lcase_headers.find("content-length") == lcase_headers.end())
                            request_stream << "Content-Length: " << request.body().size() << "\r\n";

                        if (lcase_headers.find("content-type") == lcase_headers.end())
                            request_stream << "Content-Type: text/plain\r\n";
                    }

                    if (lcase_headers.find("host") == lcase_headers.end())
                        request_stream << "Host: " << request_.url().hostAndPort() << "\r\n";

                    request_stream << "\r\n";

                    if (!request_.body().empty() && request_.istream() != NULL)
                    {
                        if (lcase_headers.find("transfer-encoding") != lcase_headers.end() &&
                            boost::to_lower_copy(lcase_headers["transfer-encoding"]) != "chunked")
                        {
                            raise_error(boost::asio::error::invalid_argument,
                                        "Client cannot send request with unknown transfer encoding");
                            if (!request_callback.empty())
                            {
                                do_not_poll = true;
                                request_callback(*this, request_, ec);
                                do_not_poll = false;
                            }
                            clear_buffers();
                            return false;
                        }
                        if (lcase_headers.find("transfer-encoding") == lcase_headers.end())
                            request_.headers()["transfer-encoding"] = "chunked";
                        // request body is sent in handle_write_request()
                    }
                    else
                        request_stream << request_.body();

#ifdef NET_REQUEST_DEBUG
                    boost::asio::streambuf::const_buffers_type bufs = request_buf.data();
                    std::string debug_str(boost::asio::buffers_begin(bufs),
                                          boost::asio::buffers_begin(bufs) + request_buf.size());
                    boost::replace_all(debug_str, "\n", "\nNETREQUEST: ");
                    std::cout << debug_str << "\n";
#endif

                    deadline_.expires_from_now(timeout_);

                    // Send request...
#ifdef ENABLE_SSL
                    if (ssock)
                    {
                        boost::asio::async_write(*ssock, request_buf,
                                  boost::bind(&Connection::handle_write_request, this,
                                    boost::asio::placeholders::error));
                    }
                    else
#endif
                    {
                        boost::asio::async_write(*sock, request_buf,
                                  boost::bind(&Connection::handle_write_request, this,
                                    boost::asio::placeholders::error));
                    }

                    start_timeout();

                    return true;
                }
                catch (boost::system::system_error &e)
                {
#ifdef NET_REQUEST_DEBUG
                    std::cout << "NETREQUEST: sendRequest(): " << e.what() << std::endl;
#endif
                    disconnect();
                    raise_error(e.code(), e.what());
                    return false;
                }
            }

            // Whether the connection is busy, e.g. processing a request/response transfer.
            bool busy() const {return in_progress;}

            // Clears the error raised in the connection. The error is only cleared
            // automatically when initiating a new connection.
            void clearError() {ec = boost::system::error_code(); emessage.clear();}
            bool success() const {return !ec;}
            const boost::system::error_code error() const {return ec;}
            const std::string &errorMessage() const {return emessage;}

            // Set up handlers for this connection.
            // The connect handler is Connection::DefaultConnectHandler by default.
            ConnectHandler connectHandler() const {return connect_callback;}
            DisconnectHandler disconnectHandler() const {return disconnect_callback;}
            RequestHandler requestHandler() const {return request_callback;}
            ResponseHandler responseHandler() const {return response_callback;}
            ResponseHandler partialResponseHandler() const {return partial_response_callback;}
            ResponseType partialResponseType() const {return partial_response_type;}
            DestructorHandler destructorHandler() const {return destructor_callback;}
            UploadProgressHandler uploadProgressHandler() const {return upload_progress_callback;}
            DownloadProgressHandler downloadProgressHandler() const {return download_progress_callback;}
#ifdef ENABLE_SSL
            VerifyHandler verifyHandler() const {return verify_callback;}
#endif
            void setConnectHandler(ConnectHandler handler) {connect_callback = handler;}
            void setDisconnectHandler(DisconnectHandler handler) {disconnect_callback = handler;}
            void setRequestHandler(RequestHandler handler) {request_callback = handler;}
            void setResponseHandler(ResponseHandler handler) {response_callback = handler;}
            void setPartialResponseHandler(ResponseHandler handler) {partial_response_callback = handler;}
            void setPartialResponseType(ResponseType type) {partial_response_type = type;}
            void setDestructorHandler(DestructorHandler handler) {destructor_callback = handler;}
            void setUploadProgressHandler(UploadProgressHandler handler) {upload_progress_callback = handler;}
            void setDownloadProgressHandler(DownloadProgressHandler handler) {download_progress_callback = handler;}
#ifdef ENABLE_SSL
            void setVerifyHandler(VerifyHandler handler) {verify_callback = handler;}
#endif

            // Set/get timeout interval and mode
            // The settings go into effect immediately after the current timeout cycle ends
            void setTimeout(boost::posix_time::time_duration timeout) {timeout_ = timeout;}
            const boost::posix_time::time_duration &timeout() const {return timeout_;}

            void setTimeoutMode(TimeoutMode mode) {timeout_mode_ = mode;}
            TimeoutMode timeoutMode() const {return timeout_mode_;}

#ifdef ENABLE_SSL
            // Set/get SSL/TLS context for this connection
            void setSslContext(std::shared_ptr<boost::asio::ssl::context> ssl_ctx) {sock_ctx = ssl_ctx;}
            std::shared_ptr<boost::asio::ssl::context> sslContext() {return sock_ctx;}
#endif

        protected:
            void disconnect_internal(bool sent_from_handler)
            {
                boost::system::error_code ignored_ec;
                running_ = reconnecting_ = false;
                stop_timeout();
#ifdef ENABLE_SSL
                if (ssock)
                {
                    if (sock_secure)
                    {
                        sock_secure = false;
                        if (sent_from_handler)
                        {
                            boost::system::error_code ssl_ec;
                            ssock->shutdown(ssl_ec);
                        }
                        else
                        {
                            ssock->async_shutdown(boost::bind(&Connection::handle_ssl_shutdown, this, _1));
                            return;
                        }
                    }
                    stop();
                    ssock->lowest_layer().shutdown(tcp::socket::shutdown_both, ignored_ec);
                    ssock->lowest_layer().close(ignored_ec);
                    ssock.reset();
                    if (!disconnect_callback.empty())
                    {
                        do_not_poll = true;
                        disconnect_callback(*this, ec);
                        do_not_poll = false;
                    }
                }
                else
#else
                (void) sent_from_handler;
#endif
                    if (sock)
                {
                    stop();
                    sock->shutdown(tcp::socket::shutdown_both, ignored_ec);
                    sock->close(ignored_ec);
                    sock.reset();
                    if (!disconnect_callback.empty())
                    {
                        do_not_poll = true;
                        disconnect_callback(*this, ec);
                        do_not_poll = false;
                    }
                }
                connect_work.reset();
                connection_work.reset();
                transaction_work.reset();
                clear_buffers();
            }

            void reconnect(bool sent_from_handler)
            {
#ifdef ENABLE_SSL
                bool secure = ssock != NULL;
#else
                (void) sent_from_handler;
#endif
                boost::system::error_code ignored_ec;
                in_progress = running_ = false;
                stop_timeout();
#ifdef ENABLE_SSL
                if (ssock)
                {
                    if (sock_secure)
                    {
                        sock_secure = false;
                        if (sent_from_handler)
                        {
                            boost::system::error_code ssl_ec;
                            ssock->shutdown(ssl_ec);
                        }
                        else
                        {
                            ssock->async_shutdown(boost::bind(&Connection::handle_ssl_shutdown_reconnect, this, _1));
                            return;
                        }
                    }
                    ssock->lowest_layer().shutdown(tcp::socket::shutdown_both, ignored_ec);
                    ssock->lowest_layer().close(ignored_ec);
                    ssock.reset();
                }
                else
#endif
                    if (sock)
                {
                    sock->shutdown(tcp::socket::shutdown_both, ignored_ec);
                    sock->close(ignored_ec);
                    sock.reset();
                }

                clear_buffers();

#ifdef NET_REQUEST_DEBUG
                std::cout << "NETREQUEST: reconnect(): in_progress: " << in_progress << std::endl;
#endif

                try
                {
                    tcp::resolver::query query(host_, service_,
                                               boost::asio::ip::resolver_query_base::canonical_name);

#ifdef ENABLE_SSL
                    if (secure)
                    {
                        if (!sock_ctx)
                            throw boost::asio::error::invalid_argument;

                        ssock.reset(new boost::asio::ssl::stream<tcp::socket>(io_serv, *sock_ctx));

                        ssock->set_verify_callback(boost::bind(&Connection::verify_certificate, this, _1, _2));
                    }
                    else
#endif
                        sock.reset(new tcp::socket(io_serv));

                    deadline_.expires_from_now(timeout_);

                    resolver_.async_resolve(query, boost::bind(&Connection::handle_resolve, this,
                                                               boost::asio::placeholders::error,
                                                               boost::asio::placeholders::iterator));

                    if (!connect_work)
                        connect_work.reset(new boost::asio::io_service::work(io_serv));

                    start_timeout();
                }
                catch (boost::system::system_error &e)
                {
                    stop_timeout();
#ifdef ENABLE_SSL
                    sock_secure = false;
                    ssock.reset();
#endif
                    sock.reset();
                    connect_work.reset();
                    connection_work.reset();
                    transaction_work.reset();
                    topLevel_.clear();
                    host_.clear();
                    service_.clear();
                    raise_error(e.code(), e.what());
                    if (!connect_callback.empty())
                    {
                        do_not_poll = true;
                        connect_callback(*this, ec);
                        do_not_poll = false;
                    }
                    return;
                }

#ifdef ENABLE_SSL
                sock_secure = false;
#endif
                running_ = reconnecting_ = true;
                clearError();
#ifdef NET_REQUEST_DEBUG
                std::cout << "NETREQUEST: reconnect(): second in_progress: " << in_progress << std::endl;
#endif
            }

            void handle_ssl_shutdown(const boost::system::error_code &err)
            {
#ifdef NET_REQUEST_DEBUG
                std::cout << "NETREQUEST: handle_ssl_shutdown" << std::endl;
#endif
                (void) err;
                disconnect();
            }

            void handle_ssl_shutdown_reconnect(const boost::system::error_code &err)
            {
#ifdef NET_REQUEST_DEBUG
                std::cout << "NETREQUEST: handle_ssl_shutdown_reconnect" << std::endl;
#endif
                (void) err;
                reconnect(false);
            }

            void finish_request()
            {
                transaction_work.reset();
                in_progress = false;
            }

            void start_timeout()
            {
                deadline_running_ = true;
                deadline_.async_wait(boost::bind(&Connection::check_timeout, this));
            }

            void stop_timeout()
            {
                deadline_running_ = false;
                deadline_.expires_from_now(boost::posix_time::pos_infin);
                try {deadline_.cancel();} catch (boost::system::system_error &) {}
            }

            void check_timeout()
            {
                if (!deadline_running_ || !running_ || ec)
                    return;

                if (deadline_.expires_at() <= boost::asio::deadline_timer::traits_type::now())
                {
#ifdef NET_REQUEST_DEBUG
                    std::cout << "NETREQUEST: timed out." << std::endl;
#endif
                    stop_timeout();
                    // The deadline has passed. The socket is closed so that any outstanding
                    // asynchronous operations are cancelled.
                    raise_error(boost::asio::error::timed_out);
#ifdef NET_REQUEST_DEBUG
                    std::cout << "NETREQUEST: sock_secure? " << sock_secure << std::endl;
#endif
                    disconnectImmediately();
                }
                else
                    // Put the actor back to sleep.
                    start_timeout();
            }

            void handle_resolve(const boost::system::error_code &err,
                                tcp::resolver::iterator endpoint_iterator)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_resolve" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (!err)
                {
                    // Attempt a connection to each endpoint in the list until we
                    // successfully establish a connection.
                    start_connect(endpoint_iterator);
                }
                else
                {
                    raise_error(err);
                    in_progress = false;
                    if (!connect_callback.empty())
                    {
                        do_not_poll = true;
                        connect_callback(*this, ec);
                        do_not_poll = false;
                    }
                    disconnect();
                }
            }

            void start_connect(tcp::resolver::iterator endpoint_iterator)
            {
                if (endpoint_iterator != tcp::resolver::iterator())
                {
                    if (timeout_mode_ == TimeoutPerOperation)
                        deadline_.expires_from_now(timeout_);

#ifdef ENABLE_SSL
                    if (ssock)
                    {
                        ssock->lowest_layer().async_connect(endpoint_iterator->endpoint(),
                                            boost::bind(&Connection::handle_connect, this, endpoint_iterator, _1));
                    }
                    else
#endif
                    {
                        sock->async_connect(endpoint_iterator->endpoint(),
                                            boost::bind(&Connection::handle_connect, this, endpoint_iterator, _1));
                    }
                }
                else
                {
                    raise_error(boost::asio::error::host_unreachable);
                    stop_timeout();
                    if (!connect_callback.empty())
                    {
                        do_not_poll = true;
                        connect_callback(*this, ec);
                        do_not_poll = false;
                    }
                    disconnect();
                }
            }

#ifdef ENABLE_SSL
            bool verify_certificate(bool preverified, boost::asio::ssl::verify_context &ctx)
            {
                if (!verify_callback.empty())
                {
                    do_not_poll = true;
                    bool b = verify_callback(*this, preverified, ctx);
                    do_not_poll = false;
                    return b;
                }

                return boost::asio::ssl::rfc2818_verification(host_)(preverified, ctx);
            }
#endif

            void handle_connect(tcp::resolver::iterator endpoint_iterator,
                    const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_connect" << std::endl;
#endif
                if ((!running_ || ec) && ec != boost::asio::error::timed_out)
                    return;

                // The async_connect() function automatically opens the socket at the start
                // of the asynchronous operation. If the socket is closed at this time then
                // the timeout handler must have run first.
                if (disconnected())
                {
#ifdef NET_RESPONSE_DEBUG
                    std::cout << "NETRESPONSE: socket is not connected, trying next endpoint" << std::endl;
#endif
                    // Try the next available endpoint.
                    start_connect(++endpoint_iterator);
                }
                // Check if the connect operation failed before the deadline expired.
                else if (err)
                {
#ifdef NET_RESPONSE_DEBUG
                    std::cout << "NETRESPONSE: error in connection, " << err.message() << ", trying next endpoint" << std::endl;
#endif

                    // We need to close the socket used in the previous connection attempt
                    // before starting a new one.
                    boost::system::error_code ignored;
#ifdef ENABLE_SSL
                    if (ssock)
                    {
                        ssock->lowest_layer().shutdown(tcp::socket::shutdown_both, ignored);
                        ssock->lowest_layer().close(ignored);
                    }
                    else
#endif
                    {
                        sock->shutdown(tcp::socket::shutdown_both, ignored);
                        sock->close(ignored);
                    }

                    // Try the next available endpoint.
                    start_connect(++endpoint_iterator);
                }
                // Otherwise we have successfully established a connection.
                else
                {
#ifdef NET_RESPONSE_DEBUG
                    std::cout << "NETRESPONSE: successfully established connection" << std::endl;
#endif

                    ec = boost::system::error_code();
                    emessage.clear();
#ifdef ENABLE_SSL
                    if (ssock)
                    {
                        if (timeout_mode_ == TimeoutPerOperation)
                            deadline_.expires_from_now(timeout_);

                        ssock->async_handshake(boost::asio::ssl::stream_base::client,
                                               boost::bind(&Connection::handle_handshake, this, _1));
                        return;
                    }
#endif

                    stop_timeout();
                    if (!connect_callback.empty())
                    {
                        do_not_poll = true;
                        connect_callback(*this, err);
                        do_not_poll = false;
                    }
                    connect_work.reset();
                }
            }

            void handle_handshake(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_handshake" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (err)
                {
#ifdef NET_RESPONSE_DEBUG
                    std::cout << "NETRESPONSE: " << err.message() << "\n";
#endif
                    raise_error(err);
                }
#ifdef ENABLE_SSL
                else
                    sock_secure = true;
#endif

                if (!transaction_work)
                    stop_timeout();
                else
                    deadline_.expires_from_now(timeout_);

                if (!connect_callback.empty())
                {
                    do_not_poll = true;
                    connect_callback(*this, err);
                    do_not_poll = false;
                }
                connect_work.reset();

                if (err)
                    disconnect();
            }

            void handle_write_request(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_write_request" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (!err)
                {
                    if (!request_.body().empty() || request_.istream() == NULL || request_.istream()->eof())
                    {
                        if (!request_callback.empty())
                        {
                            do_not_poll = true;
                            request_callback(*this, request_, err);
                            do_not_poll = false;
                        }

                        if (timeout_mode_ == TimeoutPerOperation)
                            deadline_.expires_from_now(timeout_);

                        // Read the response status line. The response_buf streambuf will
                        // automatically grow to accommodate the entire line. The growth may be
                        // limited by passing a maximum size to the streambuf constructor.
#ifdef ENABLE_SSL
                        if (ssock)
                        {
                            boost::asio::async_read_until(*ssock, response_buf, "\r\n",
                                boost::bind(&Connection::handle_read_status_line, this,
                                  boost::asio::placeholders::error));
                        }
                        else
#endif
                        {
                            boost::asio::async_read_until(*sock, response_buf, "\r\n",
                                boost::bind(&Connection::handle_read_status_line, this,
                                  boost::asio::placeholders::error));
                        }
                    }
                    else
                    {
                        std::ostream request_stream(&request_buf);
                        std::string str;
                        const size_t lim = 7 * 1024;
                        size_t ctr = 0;
                        char c = 0;
                        str.reserve(lim);
                        request_stream << std::hex;
                        while (ctr < lim && request_.istream()->get(c))
                        {
                            str.push_back(c);
                            ++ctr;
                        }
                        request_stream << ctr << "\r\n";
                        if (ctr)
                            request_stream << str << "\r\n";
                        // if ctr == 0, we sent the trailing empty chunk,
                        // and if ctr == lim, we may need to send more chunks.
                        if (ctr == 0 || ctr == lim)
                        {
#ifdef ENABLE_SSL
                            if (ssock)
                            {
                                boost::asio::async_write(*ssock, request_buf,
                                          boost::bind(&Connection::handle_write_request, this,
                                            boost::asio::placeholders::error));
                            }
                            else
#endif
                            {
                                boost::asio::async_write(*sock, request_buf,
                                          boost::bind(&Connection::handle_write_request, this,
                                            boost::asio::placeholders::error));
                            }
                        }
                        else // not a full buffer, we need to send a trailing empty chunk
                        {
#ifdef ENABLE_SSL
                            if (ssock)
                            {
                                boost::asio::async_write(*ssock, request_buf,
                                          boost::bind(&Connection::handle_write_last_chunk_request, this,
                                            boost::asio::placeholders::error));
                            }
                            else
#endif
                            {
                                boost::asio::async_write(*sock, request_buf,
                                          boost::bind(&Connection::handle_write_last_chunk_request, this,
                                            boost::asio::placeholders::error));
                            }
                        }
                    }
                }
                else if (!should_reconnect(err))
                {
                    raise_error(err);
                    in_progress = false;
                    if (!request_callback.empty())
                    {
                        do_not_poll = true;
                        request_callback(*this, request_, err);
                        do_not_poll = false;
                    }
                    handle_end_transaction(err);
                }
            }

            void handle_write_last_chunk_request(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_write_last_chunk_request" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (!err)
                {
                    std::ostream request_stream(&request_buf);
                    request_stream << "0\r\n";
#ifdef ENABLE_SSL
                    if (ssock)
                    {
                        boost::asio::async_write(*ssock, request_buf,
                                  boost::bind(&Connection::handle_write_request, this,
                                    boost::asio::placeholders::error));
                    }
                    else
#endif
                    {
                        boost::asio::async_write(*sock, request_buf,
                                  boost::bind(&Connection::handle_write_request, this,
                                    boost::asio::placeholders::error));
                    }
                }
                else if (!should_reconnect(err))
                {
                    raise_error(err);
                    in_progress = false;
                    if (!request_callback.empty())
                    {
                        do_not_poll = true;
                        request_callback(*this, request_, err);
                        do_not_poll = false;
                    }
                    handle_end_transaction(err);
                }
            }

            void handle_read_status_line(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_read_status_line" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (!err)
                {
                    // Check that response is OK.
                    std::istream response_stream(&response_buf);
                    std::string http_version;
                    response_stream >> http_version;
                    unsigned int status_code;
                    response_stream >> status_code;
                    std::string status_message;
                    std::getline(response_stream, status_message);
                    if (!response_stream || http_version.substr(0, 5) != "HTTP/")
                    {
                        raise_error(boost::asio::error::try_again,
                                    "Invalid response from server");
                        if (!response_callback.empty())
                        {
                            do_not_poll = true;
                            response_callback(*this, response_, ec);
                            do_not_poll = false;
                        }
                        return;
                    }

                    response_.setCode(static_cast<StatusCode>(status_code));
                    response_.setGroup(static_cast<StatusCode>(status_code / 100));
                    response_.setMessage(boost::trim_copy(status_message));

                    if (timeout_mode_ == TimeoutPerOperation)
                        deadline_.expires_from_now(timeout_);

                    // Read the response headers, which are terminated by a blank line.
#ifdef ENABLE_SSL
                    if (ssock)
                    {
                        boost::asio::async_read_until(*ssock, response_buf, "\r\n\r\n",
                            boost::bind(&Connection::handle_read_headers, this,
                              boost::asio::placeholders::error));
                    }
                    else
#endif
                    {
                        boost::asio::async_read_until(*sock, response_buf, "\r\n\r\n",
                            boost::bind(&Connection::handle_read_headers, this,
                              boost::asio::placeholders::error));
                    }
                }
                else if (!should_reconnect(err))
                {
                    raise_error(err);
                    // End connection and handle response as necessary
                    handle_end_transaction(err);
                }
            }

            void handle_read_headers(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_read_headers" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (!err)
                {
                    // Process the response headers.
                    std::istream response_stream(&response_buf);
                    std::string header;

                    response_.headers().clear();
                    lcase_headers.clear();
                    for (Headers::const_iterator i = request_.headers().begin(); i != request_.headers().end(); ++i)
                        lcase_headers[boost::to_lower_copy(i->first)] = i->second;

                    transfer_encoding_iterator = response_.headers().end();
                    lcase_transfer_encoding_iterator = lcase_headers.end();
                    trailer_iterator = response_.headers().end();
                    lcase_trailer_iterator = lcase_headers.end();

                    while (std::getline(response_stream, header) && header != "\r")
                    {
                        size_t index = header.find(':');
                        if (index != std::string::npos)
                        {
                            std::string header_name = boost::trim_copy(header.substr(0, index));
                            std::string header_body = boost::trim_copy(header.substr(index + 1));
                            std::string lcase_header_name = boost::to_lower_copy(header_name);

                            response_.headers()[header_name] = header_body;
                            lcase_headers[lcase_header_name] = header_body;

                            if (lcase_header_name == "transfer-encoding")
                            {
                                transfer_encoding_iterator = response_.headers().find(header_name);
                                lcase_transfer_encoding_iterator = lcase_headers.find(lcase_header_name);
                            }
                            else if (lcase_header_name == "trailer")
                            {
                                trailer_iterator = response_.headers().find(header_name);
                                lcase_trailer_iterator = lcase_headers.find(lcase_header_name);
                            }
                        }
                    }

                    if (request_.lowercaseHeaderNames())
                    {
                        response_.setHeaders(lcase_headers);
                        transfer_encoding_iterator = response_.headers().find("transfer-encoding");
                        trailer_iterator = response_.headers().find("trailer");
                    }

                    // Handle cases where there should be no message body
                    total_size = chunk_size = 0;
                    if (method == "HEAD" || (method == "CONNECT" && response_.group() == 2) ||
                            response_.group() == 1 || response_.code() == 204 || response_.code() == 304)
                        handle_end_transaction(boost::system::error_code());
                    else
                        handle_response();
                }
                else if (!should_reconnect(err))
                {
                    raise_error(err);
                    // End connection and handle response as necessary
                    handle_end_transaction(err);
                }
            }

            void handle_response()
            {
                if (lcase_headers.find("transfer-encoding") != lcase_headers.end())
                {
                    std::string encoding = boost::to_lower_copy(lcase_headers["transfer-encoding"]);
                    if (encoding.substr(encoding.size()-7) == "chunked")
                    {
                        if (timeout_mode_ == TimeoutPerOperation)
                            deadline_.expires_from_now(timeout_);

#ifdef ENABLE_SSL
                        if (ssock)
                        {
                            boost::asio::async_read_until(*ssock, response_buf, "\r\n",
                                boost::bind(&Connection::handle_read_content_chunk_size, this,
                                  boost::asio::placeholders::error));
                        }
                        else
#endif
                        {
                            boost::asio::async_read_until(*sock, response_buf, "\r\n",
                                boost::bind(&Connection::handle_read_content_chunk_size, this,
                                  boost::asio::placeholders::error));
                        }
                    }
                    else
                        raise_error(boost::asio::error::invalid_argument, "Client does not support specified transfer encoding");
                }
                else
                {
                    if (lcase_headers.find("content-length") != lcase_headers.end())
                    {
                        // chunk_size holds bytes left to read, total_size holds entire response size
                        chunk_size = total_size = boost::lexical_cast<uint64_t>(lcase_headers["content-length"]);
                        handle_read_content_sized(boost::system::error_code());
                    }
                    else
                    {
                        handle_read_content_unsized(boost::system::error_code());
                    }
                }
            }

            void handle_read_content_chunk_size(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_read_content_chunk_size" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (!err)
                {
                    std::istream response_stream(&response_buf);
                    std::string chunk_header;
                    // Read first chunk data
                    std::getline(response_stream, chunk_header);
                    chunk_size = strtoul(chunk_header.c_str(), NULL, 16);
                    // Continue if non-zero
                    if (chunk_size != 0)
                    {
                        if (chunk_size + 2 > response_buf.size())
                        {
                            // Continue reading remaining data until EOF.
#ifdef ENABLE_SSL
                            if (ssock)
                            {
                                boost::asio::async_read(*ssock, response_buf,
                                    boost::asio::transfer_exactly(chunk_size + 2 - response_buf.size()),
                                    boost::bind(&Connection::handle_read_content_chunk, this,
                                      boost::asio::placeholders::error));
                            }
                            else
#endif
                            {
                                boost::asio::async_read(*sock, response_buf,
                                    boost::asio::transfer_exactly(chunk_size + 2 - response_buf.size()),
                                    boost::bind(&Connection::handle_read_content_chunk, this,
                                      boost::asio::placeholders::error));
                            }
                            return;
                        }

                        handle_read_content_chunk(err);
                        return;
                    }

                    // Read the trailers
#ifdef ENABLE_SSL
                    if (ssock)
                    {
                        boost::asio::async_read_until(*ssock, response_buf, "\r\n",
                            boost::bind(&Connection::handle_read_content_chunk_trailers, this,
                              boost::asio::placeholders::error));
                    }
                    else
#endif
                    {
                        boost::asio::async_read_until(*sock, response_buf, "\r\n",
                            boost::bind(&Connection::handle_read_content_chunk_trailers, this,
                              boost::asio::placeholders::error));
                    }
                }
                else
                {
                    raise_error(err);
                    // End connection and handle response as necessary
                    handle_end_transaction(err);
                }
            }

            void handle_read_content_chunk(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_read_content_chunk" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (!err)
                {
                    // When this handler is called, the response buffer contains AT LEAST the chunk size
                    // PLUS the ending CRLF
                    boost::asio::streambuf::const_buffers_type bufs = response_buf.data();
                    std::string chunk = std::string(boost::asio::buffers_begin(bufs),
                                                    boost::asio::buffers_begin(bufs) + chunk_size);
                    if (request_.ostream() == NULL)
                        response_.body() += chunk;
                    else
                        *request_.ostream() << chunk;

                    total_size += chunk_size;

                    // Consume chunk and CRLF following chunk
                    response_buf.consume(chunk_size+2);

                    if (!download_progress_callback.empty())
                    {
                        do_not_poll = true;
                        download_progress_callback(*this, chunk_size, total_size, UINT64_MAX);
                        do_not_poll = false;
                    }

                    if (!partial_response_callback.empty() && partial_response_type == ResponseAny)
                    {
                        Response r(response_);
                        r.setBody(chunk);
                        do_not_poll = true;
                        partial_response_callback(*this, r, err);
                        do_not_poll = false;
                    }

                    handle_partial_response_newline(chunk, err);

                    // Read the next chunk's size
#ifdef ENABLE_SSL
                    if (ssock)
                    {
                        boost::asio::async_read_until(*ssock, response_buf, "\r\n",
                            boost::bind(&Connection::handle_read_content_chunk_size, this,
                              boost::asio::placeholders::error));
                    }
                    else
#endif
                    {
                        boost::asio::async_read_until(*sock, response_buf, "\r\n",
                            boost::bind(&Connection::handle_read_content_chunk_size, this,
                              boost::asio::placeholders::error));
                    }
                }
                else
                {
                    raise_error(err);
                    // End connection and handle response as necessary
                    handle_end_transaction(err);
                }
            }

            void handle_read_content_chunk_trailers(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_read_content_chunk_trailers" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (!err)
                {
                    std::istream response_stream(&response_buf);
                    std::string trailer_header;
                    if (std::getline(response_stream, trailer_header) && trailer_header != "\r")
                    {
                        size_t index = trailer_header.find(':');
                        if (index != std::string::npos)
                        {
                            std::string header_name = boost::trim_copy(trailer_header.substr(0, index));
                            std::string lcase_name = boost::to_lower_copy(header_name);
                            std::string header_body = boost::trim_copy(trailer_header.substr(index + 1));
                            // Ignore invalid trailer headers
                            /* TODO: verify that this is the complete list of rejected headers */
                            if (    /* MESSAGE FRAMING */
                                    lcase_name != "transfer-encoding" &&
                                    lcase_name != "content-length" &&

                                    /* ROUTING */
                                    lcase_name != "host" &&

                                    /* PAYLOAD PROCESSING */
                                    lcase_name != "content-encoding" &&
                                    lcase_name != "content-type" &&
                                    lcase_name != "content-range" &&
                                    lcase_name != "trailer" &&

                                    /* REQUEST CONTROLS */
                                    lcase_name != "cache-control" &&
                                    lcase_name != "expect" &&
                                    lcase_name != "max-forwards" &&
                                    lcase_name != "pragma" &&
                                    lcase_name != "range" &&
                                    lcase_name != "te" &&

                                    /* REQUEST CONDITIONS */
                                    lcase_name != "if-match" &&
                                    lcase_name != "if-none-match" &&
                                    lcase_name != "if-modified-since" &&
                                    lcase_name != "if-unmodified-since" &&
                                    lcase_name != "if-range" &&

                                    /* AUTHENTICATION, RFC 7235 */
                                    lcase_name != "www-authenticate" &&
                                    lcase_name != "authorization" &&
                                    lcase_name != "proxy-authenticate" &&
                                    lcase_name != "proxy-authorization" &&

                                    /* AUTHENTICATION, RFC 6265 */
                                    lcase_name != "cookie" &&
                                    lcase_name != "set-cookie" &&

                                    /* RESPONSE CONTROL DATA */
                                    lcase_name != "age" &&
                                    lcase_name != "cache-control" &&
                                    lcase_name != "expires" &&
                                    lcase_name != "date" &&
                                    lcase_name != "location" &&
                                    lcase_name != "retry-after" &&
                                    lcase_name != "vary" &&
                                    lcase_name != "warning")
                            {
                                response_.headers()[header_name] = header_body;
                                lcase_headers[lcase_name] = header_body;
                            }
                        }
#ifdef ENABLE_SSL
                        if (ssock)
                        {
                            boost::asio::async_read_until(*ssock, response_buf, "\r\n",
                                boost::bind(&Connection::handle_read_content_chunk_trailers, this,
                                  boost::asio::placeholders::error));
                        }
                        else
#endif
                        {
                            boost::asio::async_read_until(*sock, response_buf, "\r\n",
                                boost::bind(&Connection::handle_read_content_chunk_trailers, this,
                                  boost::asio::placeholders::error));
                        }
                        return;
                    }
                    // Erase "chunked" from Transfer-Encoding
                    std::string encoding = boost::to_lower_copy(lcase_headers["transfer-encoding"]);
                    size_t idx = encoding.find_last_of(',');
                    if (transfer_encoding_iterator != response_.headers().end())
                    {
                        if (idx == std::string::npos)
                        {
                            response_.headers().erase(transfer_encoding_iterator);
                            lcase_headers.erase(lcase_transfer_encoding_iterator);
                        }
                        else
                        {
                            transfer_encoding_iterator->second.erase(idx, std::string::npos);
                            lcase_transfer_encoding_iterator->second.erase(idx, std::string::npos);
                        }
                    }
                    // Remove "Trailer" header from response
                    if (trailer_iterator != response_.headers().end())
                    {
                        response_.headers().erase(trailer_iterator);
                        lcase_headers.erase(lcase_trailer_iterator);
                    }
                    // Set Content-Length field
                    {
                        std::string cast = boost::lexical_cast<std::string>(response_.body().size());
                        response_.headers()[request_.lowercaseHeaderNames()? "content-length": "Content-Length"] = cast;
                        lcase_headers["content-length"] = cast;
                    }
                }
                else
                    raise_error(err);
                // End connection and handle response as necessary
                handle_end_transaction(err);
            }

            void handle_read_content_sized(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_read_content_sized" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (!err)
                {
                    if (chunk_size)
                    {
                        uint64_t size = std::min(chunk_size, (uint64_t) response_buf.size());
                        boost::asio::streambuf::const_buffers_type bufs = response_buf.data();
                        std::string chunk = std::string(boost::asio::buffers_begin(bufs),
                                                        boost::asio::buffers_begin(bufs) + size);

                        if (request_.ostream() == NULL)
                            response_.body() += chunk;
                        else
                            *request_.ostream() << chunk;

                        response_buf.consume((size_t) size);
                        chunk_size -= size;

                        if (!partial_response_callback.empty() && partial_response_type == ResponseAny)
                        {
                            Response r(response_);
                            r.setBody(chunk);
                            do_not_poll = true;
                            partial_response_callback(*this, r, err);
                            do_not_poll = false;
                        }

                        if (!download_progress_callback.empty())
                        {
                            do_not_poll = true;
                            download_progress_callback(*this, size, total_size - chunk_size, total_size);
                            do_not_poll = false;
                        }

                        handle_partial_response_newline(chunk, err);
                    }

#ifdef NET_RESPONSE_DEBUG
                    std::cout << "NETRESPONSE: handle_read_content_sized queueing new read" << std::endl;
#endif
                    if (chunk_size)
                    {
                        // Read remaining data.
                        if (timeout_mode_ == TimeoutPerOperation)
                            deadline_.expires_from_now(timeout_);

#ifdef ENABLE_SSL
                        if (ssock)
                        {
                            boost::asio::async_read(*ssock, response_buf,
                                boost::asio::transfer_at_least(1),
                                boost::bind(&Connection::handle_read_content_sized, this,
                                  boost::asio::placeholders::error));
                        }
                        else
#endif
                        {
                            boost::asio::async_read(*sock, response_buf,
                                boost::asio::transfer_at_least(1),
                                boost::bind(&Connection::handle_read_content_sized, this,
                                  boost::asio::placeholders::error));
                        }
                        return;
                    }
                }
                else
                    raise_error(err);
                // End connection and handle response as necessary
                handle_end_transaction(err);
            }

            void handle_read_content_unsized(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_read_content_unsized" << std::endl;
#endif
                if (!running_ || ec)
                    return;

                if (!err)
                {
                    // Write all of the data that has been read so far.
                    boost::asio::streambuf::const_buffers_type bufs = response_buf.data();
                    std::string chunk = std::string(boost::asio::buffers_begin(bufs),
                                                    boost::asio::buffers_begin(bufs) + response_buf.size());
                    if (request_.ostream() == NULL)
                        response_.body() += chunk;
                    else
                        *request_.ostream() << chunk;

                    total_size += response_buf.size();
                    response_buf.consume(response_buf.size());

                    if (!partial_response_callback.empty() && partial_response_type == ResponseAny)
                    {
                        Response r(response_);
                        r.setBody(chunk);
                        do_not_poll = true;
                        partial_response_callback(*this, r, err);
                        do_not_poll = false;
                    }

                    if (!download_progress_callback.empty())
                    {
                        do_not_poll = true;
                        download_progress_callback(*this, chunk.size(), total_size, UINT64_MAX);
                        do_not_poll = false;
                    }

                    handle_partial_response_newline(chunk, err);

                    if (timeout_mode_ == TimeoutPerOperation)
                        deadline_.expires_from_now(timeout_);

                    // Continue reading remaining data until EOF.
#ifdef ENABLE_SSL
                    if (ssock)
                    {
                        boost::asio::async_read(*ssock, response_buf,
                            boost::asio::transfer_at_least(1),
                            boost::bind(&Connection::handle_read_content_unsized, this,
                              boost::asio::placeholders::error));
                    }
                    else
#endif
                    {
                        boost::asio::async_read(*sock, response_buf,
                            boost::asio::transfer_at_least(1),
                            boost::bind(&Connection::handle_read_content_unsized, this,
                              boost::asio::placeholders::error));
                    }
                }
                else
                {
                    if (err != boost::asio::error::eof)
                        raise_error(err);
                    else
                    {
                        ec = boost::system::error_code();
                        emessage.clear();
                    }
                    // Set content-length field
                    {
                        std::string cast = boost::lexical_cast<std::string>(total_size);
                        response_.headers()[request_.lowercaseHeaderNames()? "content-length": "Content-Length"] = cast;
                        lcase_headers["content-length"] = cast;
                    }
                    // End connection and handle response as necessary
                    handle_end_transaction(err);
                }
            }

            void handle_end_transaction(const boost::system::error_code &err)
            {
#ifdef NET_RESPONSE_DEBUG
                std::cout << "NETRESPONSE: handle_end_transaction" << std::endl;
#endif
                in_progress = false;

                stop_timeout();

                if (!partial_response_callback.empty() && partial_response_type == ResponseWhole)
                {
                    do_not_poll = true;
                    partial_response_callback(*this, response_, err);
                    do_not_poll = false;
                }

                if (!response_callback.empty())
                {
                    do_not_poll = true;
                    response_callback(*this, response_, err);
                    do_not_poll = false;
                }

                finish_request();

                if (err ||
                    (lcase_headers.find("connection") != lcase_headers.end() &&
                     boost::to_lower_copy(lcase_headers["connection"]) == "close"))
                {
                    disconnect();
                }
            }

            void handle_partial_response_newline(const std::string &chunk, const boost::system::error_code &err)
            {
                if (!partial_response_callback.empty() && partial_response_type == ResponseLine)
                {
                    Response r(response_);
                    size_t newline;

                    chunk_line += chunk;
                    newline = chunk_line.find('\n');
                    while (newline != std::string::npos)
                    {
                        r.setBody(chunk_line.substr(0, newline+1));
                        partial_response_callback(*this, r, err);
                        chunk_line.erase(0, newline+1);
                        newline = chunk_line.find('\n');
                    }
                }
            }

            bool should_reconnect(const boost::system::error_code &err)
            {
                if (reconnect_if_aborted &&
                        (err == boost::asio::error::connection_aborted ||
                         err == boost::asio::error::connection_reset ||
                         err == boost::asio::error::eof))
                {
                    reconnect(true);
                    return true;
                }
                return false;
            }

            boost::system::error_code ec; // Raised error code
            std::string emessage; // Raised error message

            ConnectHandler connect_callback;
            DisconnectHandler disconnect_callback;
            RequestHandler request_callback;
            ResponseHandler response_callback;
            ResponseHandler partial_response_callback;
            DestructorHandler destructor_callback;
#ifdef ENABLE_SSL
            VerifyHandler verify_callback;
#endif
            UploadProgressHandler upload_progress_callback;
            DownloadProgressHandler download_progress_callback;
            ResponseType partial_response_type;

            std::string topLevel_; // Contains "scheme://host[:port]"
            std::string host_; // Contains host (server) name or address
            std::string service_; // Contains service (scheme or port number) of request

            bool in_progress; // Whether a request is currently being handled
            std::string method; // Request method for current request
            uint64_t chunk_size; // Current chunk size
            uint64_t total_size; // Total request/response size
            std::string chunk_line; // Current incomplete line of response, only enabled if partial_response_type == ResponseLine
            Request request_; // Request to send
            Response response_; // Response to parse into

            // Temporary response cache data
            Headers lcase_headers;
            Headers::iterator transfer_encoding_iterator;
            Headers::iterator lcase_transfer_encoding_iterator;
            Headers::iterator trailer_iterator;
            Headers::iterator lcase_trailer_iterator;

            // Local network/buffer objects
            boost::asio::io_service io_serv;
            tcp::resolver resolver_;
#ifdef ENABLE_SSL
            std::shared_ptr<boost::asio::ssl::context> sock_ctx;
            bool sock_secure; // Whether this is a secured HTTPS connection (is not true if handshake is not complete)
            std::unique_ptr<boost::asio::ssl::stream<tcp::socket>> ssock;
#endif
            std::unique_ptr<tcp::socket> sock;
            bool running_;
            bool reconnect_if_aborted;
            bool reconnecting_;
            boost::asio::streambuf request_buf;
            boost::asio::streambuf response_buf;

            // IO service work (to prevent run() from stopping) for convenience functions
            //   -  wait_for_connect()
            //   -  wait_for_transaction()
            //   -  wait_for_disconnect()
            std::unique_ptr<boost::asio::io_service::work> connect_work;
            std::unique_ptr<boost::asio::io_service::work> connection_work;
            std::unique_ptr<boost::asio::io_service::work> transaction_work;

            TimeoutMode timeout_mode_;
            boost::posix_time::time_duration timeout_;
            boost::asio::deadline_timer deadline_;
            bool deadline_running_;
        };

        typedef std::shared_ptr<Connection> ConnectionPtr;

        class ConnectionManager : public boost::noncopyable
        {
            struct ConnectionObject
            {
                ConnectionObject(ConnectionPtr c = 0)
                    : c(c)
                    , connect(NULL)
                    , disconnect(NULL)
                    , request(NULL)
                    , response(NULL)
                    , destructor(NULL)
                    , uploadProgress(NULL)
                    , downloadProgress(NULL)
                    , free(false)
                {}

                ConnectionPtr c;
                Connection::ConnectHandler connect;
                Connection::DisconnectHandler disconnect;
                Connection::RequestHandler request;
                Connection::ResponseHandler response;
                Connection::DestructorHandler destructor;
                Connection::ProgressHandler uploadProgress;
                Connection::ProgressHandler downloadProgress;
                bool free;
            };

            void destructor_handler(Connection &c)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c.get() == &c)
                    {
                        if (!async_connections_[i].destructor.empty())
                            async_connections_[i].destructor(c);
                        async_connections_.erase(async_connections_.begin() + i);
                        break;
                    }
            }

            void registerConnection(ConnectionPtr conn)
            {
                async_connections_.push_back(ConnectionObject(conn));
            }

            void unregisterConnection(ConnectionPtr conn)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == conn)
                    {
                        async_connections_.erase(async_connections_.begin() + i);
                        --i;
                    }
            }

        public:
#ifdef ENABLE_SSL
            ConnectionManager() : polling_(false), ctx() {setSslContext();}
#else
            ConnectionManager() : polling_(false) {}
#endif
            ~ConnectionManager()
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                {
                    async_connections_[i].c->setDestructorHandler(async_connections_[i].destructor);
                    async_connections_[i].c->disconnectImmediately();
                }
            }

            ConnectionPtr createConnection()
            {
                ConnectionPtr connection = std::make_shared<Connection>();
#ifdef ENABLE_SSL
                connection->setSslContext(ctx);
                connection->setVerifyHandler(verify_callback);
#endif
                connection->setDestructorHandler(boost::bind(&ConnectionManager::destructor_handler, this, _1));
                async_connections_.push_back(ConnectionObject(connection));
                return connection;
            }

            ConnectionPtr createConnection(const Request &request) {return createConnection(request.url());}
            ConnectionPtr createConnection(const Uri &url)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                {
                    if (async_connections_[i].free && async_connections_[i].c->topLevelDomain() == url.topLevel())
                    {
                        async_connections_[i].free = false;
                        async_connections_[i].c->reconnectOnConnAborted();
                        return async_connections_[i].c;
                    }
                }
                return createConnection();
            }

            void freeConnection(ConnectionPtr c)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                    {
                        async_connections_[i].free = true;
                        break;
                    }
            }

            void setConnectHandler(ConnectionPtr c, Connection::ConnectHandler handler)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                    {
                        async_connections_[i].c->setConnectHandler(handler);
                        break;
                    }
            }

            void setDisconnectHandler(ConnectionPtr c, Connection::DisconnectHandler handler)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                    {
                        async_connections_[i].c->setDisconnectHandler(handler);
                        break;
                    }
            }

            void setRequestHandler(ConnectionPtr c, Connection::RequestHandler handler)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                    {
                        async_connections_[i].c->setRequestHandler(handler);
                        break;
                    }
            }

            void setResponseHandler(ConnectionPtr c, Connection::ResponseHandler handler)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                    {
                        async_connections_[i].c->setResponseHandler(handler);
                        break;
                    }
            }

            void setPartialResponseHandler(ConnectionPtr c, Connection::ResponseHandler handler)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                    {
                        async_connections_[i].c->setPartialResponseHandler(handler);
                        break;
                    }
            }

#ifdef ENABLE_SSL
            void setVerifyHandler(ConnectionPtr c, Connection::VerifyHandler handler)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                    {
                        async_connections_[i].c->setVerifyHandler(handler);
                        break;
                    }
            }
#endif

            void setUploadProgressHandler(ConnectionPtr c, Connection::ProgressHandler handler)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                    {
                        async_connections_[i].c->setUploadProgressHandler(handler);
                        break;
                    }
            }

            void setDownloadProgressHandler(ConnectionPtr c, Connection::ProgressHandler handler)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                    {
                        async_connections_[i].c->setDownloadProgressHandler(handler);
                        break;
                    }
            }

            void setDestructorHandler(ConnectionPtr c, Connection::DestructorHandler handler)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                    {
                        async_connections_[i].c->setDestructorHandler(handler);
                        break;
                    }
            }

            void wait_for_connect(ConnectionPtr c) {wait_for_connect_event_loop(c, null);}
            void wait_for_transaction(ConnectionPtr c) {wait_for_transaction_event_loop(c, null);}
            void wait_for_disconnect(ConnectionPtr c) {wait_for_disconnect_event_loop(c, null);}

            template<typename T>
            void wait_for_connect_event_loop(ConnectionPtr c, T processEvents)
            {
                size_t idx = findConnection(c);
                if (idx != SIZE_MAX)
                {
                    ++polling_;
                    c->wait_later_for_connect();
                    while (1)
                    {
                        for (size_t i = 0; i < async_connections_.size(); ++i)
                        {
                            if (async_connections_[i].c == c && !c->connecting())
                            {
                                --polling_;
                                return;
                            }
                            async_connections_[i].c->poll();
                            processEvents();
                        }
                    }
                }
            }

            template<typename T>
            void wait_for_transaction_event_loop(ConnectionPtr c, T processEvents)
            {
                size_t idx = findConnection(c);
                if (idx != SIZE_MAX)
                {
                    ++polling_;
                    c->wait_later_for_transaction();
                    while (1)
                    {
                        for (size_t i = 0; i < async_connections_.size(); ++i)
                        {
                            if (async_connections_[i].c == c && !c->inTransaction())
                            {
                                --polling_;
                                return;
                            }
                            async_connections_[i].c->poll();
                            processEvents();
                        }
                    }
                }
            }

            template<typename T>
            void wait_for_disconnect_event_loop(ConnectionPtr c, T processEvents)
            {
                size_t idx = findConnection(c);
                if (idx != SIZE_MAX)
                {
                    ++polling_;
                    c->wait_later_for_disconnect();
                    while (1)
                    {
                        for (size_t i = 0; i < async_connections_.size(); ++i)
                        {
                            if (async_connections_[i].c == c && c->disconnected())
                            {
                                --polling_;
                                return;
                            }
                            async_connections_[i].c->poll();
                            processEvents();
                        }
                    }
                }
            }

            void poll()
            {
                if (!polling_)
                {
                    ++polling_;
                    for (size_t i = 0; i < async_connections_.size(); ++i)
                        async_connections_[i].c->poll();
                    --polling_;
                }
            }

            void stop()
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    async_connections_[i].c->stop();
            }

            size_t polling() const {return polling_;}

#ifdef ENABLE_SSL
            std::shared_ptr<boost::asio::ssl::context> sslContext() {return ctx;}
            void setSslContext(std::shared_ptr<boost::asio::ssl::context> context = std::shared_ptr<boost::asio::ssl::context>())
            {
                ctx = context;
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    async_connections_[i].c->setSslContext(ctx);
            }

            Connection::VerifyHandler verifyHandler() const {return verify_callback;}
            void setVerifyHandler(Connection::VerifyHandler handler) {verify_callback = handler;}
#endif

        private:
            static void null() {}

            size_t findConnection(ConnectionPtr c)
            {
                for (size_t i = 0; i < async_connections_.size(); ++i)
                    if (async_connections_[i].c == c)
                        return i;
                return SIZE_MAX;
            }

            size_t polling_;
            std::vector<ConnectionObject> async_connections_;
#ifdef ENABLE_SSL
            std::shared_ptr<boost::asio::ssl::context> ctx;
            Connection::VerifyHandler verify_callback;
#endif
        };
    }
}

#endif // CPPHTTP_H
